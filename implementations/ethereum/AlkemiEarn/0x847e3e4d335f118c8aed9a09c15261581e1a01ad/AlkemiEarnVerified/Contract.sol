{"AggregatorV3Interface.sol":{"content":"pragma solidity \u003e=0.4.24;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"},"AlkemiEarnPublicV10.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./ChainLink.sol\";\nimport \"./AlkemiWETH.sol\";\n\ncontract AlkemiEarnPublicV10 is Exponential, SafeToken {\n\n    uint internal initialInterestIndex;\n    uint internal defaultOriginationFee; \n    uint internal defaultCollateralRatio;\n    uint internal defaultLiquidationDiscount;\n\n    uint internal minimumCollateralRatioMantissa;\n    uint internal maximumLiquidationDiscountMantissa;\n    bool public initializationDone; // To make sure initializer is called only once\n\n    /**\n     * @notice `AlkemiEarnPublic` is the core AlkemiEarnPublic contract\n     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n     * @notice Hence this contract has an \u0027initializer\u0027 in place of a \u0027constructor\u0027\n     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n     */\n    function initializer() public {\n        if(initializationDone == false) {\n            initializationDone = true;\n            admin = msg.sender;\n            initialInterestIndex = 10 ** 18;\n            defaultOriginationFee = (10 ** 15); // default is 0.1%\n            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n            originationFee = Exp({mantissa: defaultOriginationFee});\n            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n            // oracle must be configured via _setOracle\n        }\n    }\n\n    /**\n     * @notice Do not pay directly into AlkemiEarnPublic, please use `supply`.\n     */\n    function() payable public {\n        revert();\n    }\n\n    /**\n     * @dev pending Administrator for this contract.\n     */\n    address public pendingAdmin;\n\n    /**\n     * @dev Administrator for this contract. Initially set in constructor, but can\n     *      be changed by the admin itself.\n     */\n    address public admin;\n\n    /**\n     * @dev Account allowed to set oracle prices for this contract. Initially set\n     *      in constructor, but can be changed by the admin.\n     */\n    address public oracle;\n\n    /**\n     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n     */\n    ChainLink priceOracle;\n\n    /**\n     * @dev Container for customer balance information written to storage.\n     *\n     *      struct Balance {\n     *        principal = customer total balance with accrued interest after applying the customer\u0027s most recent balance-changing action\n     *        interestIndex = the total interestIndex as calculated after applying the customer\u0027s most recent balance-changing action\n     *      }\n     */\n    struct Balance {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for supplies\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public supplyBalances;\n\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public borrowBalances;\n\n\n    /**\n     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n     *\n     *      struct Market {\n     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n     *         blockNumber = when the other values in this struct were calculated\n     *         totalSupply = total amount of this asset supplied (in asset wei)\n     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n     *     }\n     */\n    struct Market {\n        bool isSupported;\n        uint blockNumber;\n        InterestRateModel interestRateModel;\n\n        uint totalSupply;\n        uint supplyRateMantissa;\n        uint supplyIndex;\n\n        uint totalBorrows;\n        uint borrowRateMantissa;\n        uint borrowIndex;\n    }\n\n    /**\n     * @dev wethAddress to hold the WETH token contract address\n     * set using setWethAddress function\n     */\n    address public wethAddress;\n\n    /**\n     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n     */\n    AlkemiWETH public WETHContract;\n\n    /**\n     * @dev map: assetAddress -\u003e Market\n     */\n    mapping(address =\u003e Market) public markets;\n\n    /**\n     * @dev list: collateralMarkets\n     */\n    address[] public collateralMarkets;\n\n    /**\n     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n     *      is initially set in the constructor, but can be changed by the admin.\n     */\n    Exp public collateralRatio;\n\n    /**\n     * @dev originationFee for new borrows.\n     *\n     */\n    Exp public originationFee;\n\n    /**\n     * @dev liquidationDiscount for collateral when liquidating borrows\n     *\n     */\n    Exp public liquidationDiscount;\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    /**\n     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n    struct SupplyLocalVars {\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n    }\n\n    /**\n     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n\n    struct WithdrawLocalVars {\n        uint withdrawAmount;\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfWithdrawal;\n        uint withdrawCapacity;\n    }\n\n    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n    struct AccountValueLocalVars {\n        address assetAddress;\n        uint collateralMarketsLength;\n\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        Exp supplyTotalValue;\n        Exp sumSupplies;\n\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        Exp borrowTotalValue;\n        Exp sumBorrows;\n    }\n\n    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n    struct PayBorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint repayAmount;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n    }\n\n    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n    struct BorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint borrowAmountWithFee;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfBorrowAmountWithFee;\n    }\n\n    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n    struct LiquidateLocalVars {\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n        address targetAccount;\n        address assetBorrow;\n        address liquidator;\n        address assetCollateral;\n\n        // borrow index and supply index are global to the asset, not specific to the user\n        uint newBorrowIndex_UnderwaterAsset;\n        uint newSupplyIndex_UnderwaterAsset;\n        uint newBorrowIndex_CollateralAsset;\n        uint newSupplyIndex_CollateralAsset;\n\n        // the target borrow\u0027s full balance with accumulated interest\n        uint currentBorrowBalance_TargetUnderwaterAsset;\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\n\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\n\n        uint startingBorrowBalance_TargetUnderwaterAsset;\n        uint startingSupplyBalance_TargetCollateralAsset;\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\n\n        uint currentSupplyBalance_TargetCollateralAsset;\n        uint updatedSupplyBalance_TargetCollateralAsset;\n\n        // If liquidator already has a balance of collateralAsset, we will accumulate\n        // interest on it before transferring seized collateral from the borrower.\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\n        // This will be the liquidator\u0027s accumulated balance of collateral asset before the liquidation (if any)\n        // plus the amount seized from the borrower.\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n\n        uint newTotalSupply_ProtocolCollateralAsset;\n        uint currentCash_ProtocolUnderwaterAsset;\n        uint updatedCash_ProtocolUnderwaterAsset;\n\n        // cash does not change for collateral asset\n\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n\n        // Why no variables for the interest rates for the collateral asset?\n        // We don\u0027t need to calculate new rates for the collateral asset since neither cash nor borrows change\n\n        uint discountedRepayToEvenAmount;\n\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n        uint discountedBorrowDenominatedCollateral;\n\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        uint closeBorrowAmount_TargetUnderwaterAsset;\n        uint seizeSupplyAmount_TargetCollateralAsset;\n\n        Exp collateralPrice;\n        Exp underwaterAssetPrice;\n\n        uint reimburseAmount;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e originationFeeBalance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e uint)) public originationFeeBalance;\n\n    /**\n     * @dev Event emitted on successful addition of Weth Address\n     */\n    event WETHAddressSet(address wethAddress);\n\n    /**\n     * @dev emitted when a supply is received\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a origination fee supply is received as admin\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n    /**\n     * @dev emitted when a supply is withdrawn\n     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a new borrow is taken\n     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n     */\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is repaid\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is liquidated\n     *      targetAccount = user whose borrow was liquidated\n     *      assetBorrow = asset borrowed\n     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountRepaid = amount of borrow repaid\n     *      liquidator = account requesting the liquidation\n     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountSeized = amount of collateral seized by liquidator\n     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n     */\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    /**\n     * @dev emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev newOracle - address of new oracle\n     */\n    event NewOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev emitted when new market is supported by admin\n     */\n    event SupportedMarket(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when risk parameters are changed by admin\n     */\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n\n    /**\n     * @dev emitted when origination fee is changed by admin\n     */\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n\n    /**\n     * @dev emitted when market has new interest rate model set\n     */\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when admin withdraws equity\n     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n     */\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n\n    /**\n     * @dev emitted when a supported market is suspended by admin\n     */\n    event SuspendedMarket(address asset);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev Function to emit fail event to frontend\n     */\n    function emitError(Error error, FailureInfo failure) private returns(uint) {\n        return fail(error, failure);\n    }\n\n    /**\n     * @dev Simple function to calculate min between two numbers.\n     */\n    function min(uint a, uint b) pure internal returns (uint) {\n        if (a \u003c b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *      This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n     *      Note: this will not add the asset if it already exists.\n     */\n    function addCollateralMarket(address asset) internal {\n        for (uint i = 0; i \u003c collateralMarkets.length; i++) {\n            if (collateralMarkets[i] == asset) {\n                return;\n            }\n        }\n\n        collateralMarkets.push(asset);\n    }\n\n    /**\n     * @notice return the number of elements in `collateralMarkets`\n     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n     * @return the length of `collateralMarkets`\n     */\n    function getCollateralMarketsLength() public view returns (uint) {\n        return collateralMarkets.length;\n    }\n\n    /**\n     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n     */\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n\n        // Get the block delta\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        // Scale the interest rate times number of blocks\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n        if (err2 != Error.NO_ERROR) {\n            return (err2, 0);\n        }\n\n        // Then scale that accumulated interest by the old interest index to get the new interest index\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n        if (err3 != Error.NO_ERROR) {\n            return (err3, 0);\n        }\n\n        // Finally, truncate the interest index. This works only if interest index starts large enough\n        // that is can be accurately represented with a whole number.\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n    }\n\n    /**\n     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n     *      This is defined as: `The user\u0027s last balance checkpoint is multiplied by the currentSupplyIndex\n     *      value and divided by the user\u0027s checkpoint index value`\n     *\n     *      TODO: Is there a way to handle this that is less likely to overflow?\n     */\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n        if (startingBalance == 0) {\n            // We are accumulating interest on any previous balance; if there\u0027s no previous balance, then there is\n            // nothing to accumulate.\n            return (Error.NO_ERROR, 0);\n        }\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return div(balanceTimesIndex, interestIndexStart);\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset.\n     */\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n     */\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory scaledPrice;\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        // Now, multiply the assetValue by the collateral ratio\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        // Get the price for the given asset amount\n        return mulScalar(scaledPrice, assetAmount);\n    }\n\n    /**\n     * @dev Calculates the origination fee added to a given borrowAmount\n     *      This is simply `(1 + originationFee) * borrowAmount`\n     *\n     *      TODO: Track at what magnitude this fee rounds down to zero?\n     */\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n        // When origination fee is zero, the amount with fee is simply equal to the amount\n        if (isZeroExp(originationFee)) {\n            return (Error.NO_ERROR, borrowAmount);\n        }\n\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n    }\n\n    /**\n     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n     * @param asset asset whose price should be fetched\n     */\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n        if (oracle == address(0)) {\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n        }\n\n        uint priceMantissa = priceOracle.getAssetPrice(asset);\n\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n    }\n\n    /**\n     * @notice Reads scaled price of specified asset from the price oracle\n     * @dev Reads scaled price of specified asset from the price oracle.\n     *      The plural name is to match a previous storage mapping that this function replaced.\n     * @param asset Asset whose price should be retrieved\n     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return 0;\n        }\n        return result.mantissa;\n    }\n\n    /**\n     * @dev Gets the amount of the specified asset given the specified Eth value\n     *      ethValue / oraclePrice = assetAmountWei\n     *      If there\u0027s no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n     */\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory assetAmount;\n\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, assetAmount) = divExp(ethValue, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(assetAmount));\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller = pendingAdmin\n        // msg.sender can\u0027t be zero\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAdmin = admin;\n        // Store admin = pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = 0;\n\n        emit NewAdmin(oldAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new oracle, who can set asset prices\n     * @dev Admin function to change oracle\n     * @param newOracle New oracle address\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOracle(address newOracle) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n        }\n\n        // Verify contract at newOracle address supports assetPrices call.\n        // This will revert if it doesn\u0027t.\n        // ChainLink priceOracleTemp = ChainLink(newOracle);\n        // priceOracleTemp.getAssetPrice(address(0));\n\n        address oldOracle = oracle;\n\n        // Store oracle = newOracle\n        oracle = newOracle;\n        // Initialize the Chainlink contract in priceOracle\n        priceOracle = ChainLink(newOracle);\n\n        emit NewOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice returns the liquidity for given account.\n     *         a positive result indicates ability to borrow, whereas\n     *         a negative result indicates a shortfall which may be liquidated\n     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n     *      note: this includes interest trued up on all balances\n     * @param account the account to examine\n     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n     */\n    function getAccountLiquidity(address account) public view returns (int) {\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n        require(err == Error.NO_ERROR);\n\n        if (isZeroExp(accountLiquidity)) {\n            return -1 * int(truncate(accountShortfall));\n        } else {\n            return int(truncate(accountLiquidity));\n        }\n    }\n\n    /**\n     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose supply balance belonging to `account` should be checked\n     * @return uint supply balance on success, throws on failed assertion otherwise\n     */\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[account][asset];\n\n        // Calculate the newSupplyIndex, needed to calculate user\u0027s supplyCurrent\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n        require(err == Error.NO_ERROR);\n\n        return userSupplyCurrent;\n    }\n\n    /**\n     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n     * @return uint borrow balance on success, throws on failed assertion otherwise\n     */\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[account][asset];\n\n        // Calculate the newBorrowIndex, needed to calculate user\u0027s borrowCurrent\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n        require(err == Error.NO_ERROR);\n\n        return userBorrowCurrent;\n    }\n\n\n    /**\n     * @notice Supports a given market (asset) for use\n     * @dev Admin function to add support for a market\n     * @param asset Asset to support; MUST already have a non-zero price set\n     * @param interestRateModel InterestRateModel to use for the asset\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        // Append asset to collateralAssets if not set\n        addCollateralMarket(asset);\n\n        // Set market isSupported to true\n        markets[asset].isSupported = true;\n\n        // Default supply and borrow index to 1e18\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n\n        emit SupportedMarket(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Suspends a given *supported* market (asset) from use.\n     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n     * @dev Admin function to suspend a market\n     * @param asset Asset to suspend\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _suspendMarket(address asset) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n        }\n\n        // If the market is not configured at all, we don\u0027t want to add any configuration for it.\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n        // has already been marked as unsupported. We can just return without doing anything.\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n        if (!markets[asset].isSupported) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // If we get here, we know market is configured and is supported, so set isSupported to false\n        markets[asset].isSupported = false;\n\n        emit SuspendedMarket(asset);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n     * @dev Owner function to set the risk parameters\n     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be \u003c= 0.1 and must be less than (descaled collateral ratio minus 1)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n        }\n\n        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n\n        Error err;\n        Exp memory newLiquidationDiscountPlusOne;\n\n        // Make sure new collateral ratio value is not below minimum value\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n        // C \u003c L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Save current values so we can emit them in log.\n        Exp memory oldCollateralRatio = collateralRatio;\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\n\n        // Store new values\n        collateralRatio = newCollateralRatio;\n        liquidationDiscount = newLiquidationDiscount;\n\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the origination fee (which is a multiplier on new borrows)\n     * @dev Owner function to set the origination fee\n     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n        }\n\n        // Save current value so we can emit it in log.\n        Exp memory oldOriginationFee = originationFee;\n\n        originationFee = Exp({mantissa: originationFeeMantissa});\n\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the interest rate model for a given market\n     * @dev Admin function to set interest rate model\n     * @param asset Asset to support\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        emit SetMarketInterestRateModel(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` \u003c= equity. Equity= cash - (supply + borrows)\n     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount \u003c= cash - (supply + borrows)\n     * @param asset asset whose equity should be withdrawn\n     * @param amount amount of equity to withdraw; must not exceed equity available\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n        }\n\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n        uint cash = getCash(asset);\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n        if (err0 != Error.NO_ERROR) {\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n        }\n\n        if (amount \u003e equity) {\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset out of the protocol to the admin\n            Error err2 = doTransferOut(asset, admin, amount);\n            if (err2 != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n        emit EquityWithdrawn(asset, equity, amount, admin);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Set WETH token contract address\n     * @param wethContractAddress Enter the WETH token address\n     */\n    function setWethAddress(address wethContractAddress) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n        }\n        wethAddress = wethContractAddress;\n        WETHContract = AlkemiWETH(wethAddress);\n        emit WETHAddressSet(wethContractAddress);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n     * @return errors if any\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n        user; // To silence the warning of unused local variable\n        if(wethAddress != address(0)){\n            WETHContract.deposit.value(etherAmount)();\n            return uint(Error.NO_ERROR);\n        }\n        else {\n            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n        }\n    }\n\n    /**\n     * @dev Revert Ether paid by user back to user\u0027s account in case transaction fails due to some other reason\n     * @param etherAmount Amount of ether to be sent back to user\n     * @param user User account address\n     */\n    function revertEtherToUser(address user, uint etherAmount) internal {\n        if(etherAmount \u003e 0){\n            user.transfer(etherAmount);\n        }\n    }\n\n    /**\n     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n     * @dev add amount of supported asset to msg.sender\u0027s account\n     * @param asset The market asset to supply\n     * @param amount The amount to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function supply(address asset, uint amount) public payable returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage balance = supplyBalances[msg.sender][asset];\n\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n        }\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnPublic contract in case of ETH automatically\n            // Fail gracefully if asset is not approved or has insufficient balance\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnPublic contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n        balance.principal = localResults.userSupplyUpdated;\n        balance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice withdraw `amount` of `ether` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `ether` from msg.sender\u0027s account to msg.sender\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n            WETHContract.withdraw(user,etherAmount);\n            return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice send Ether from contract to a user\n     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n     */\n    function sendEtherToUser(address user, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n        }\n        user.transfer(amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraw `amount` of `asset` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `asset` from msg.sender\u0027s account to msg.sender\n     * @param asset The market asset to withdraw\n     * @param requestedAmount The amount to withdraw (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function withdraw(address asset, uint requestedAmount) public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // We calculate the user\u0027s accountLiquidity and accountShortfall.\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount =\u003e the lesser of withdrawCapacity and supplyCurrent\n        if (requestedAmount == uint(-1)) {\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n            }\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n        } else {\n            localResults.withdrawAmount = requestedAmount;\n        }\n\n        // From here on we should NOT use requestedAmount.\n\n        // Fail gracefully if protocol has insufficient cash\n        // If protocol has insufficient cash, the sub operation will underflow.\n        localResults.currentCash = getCash(asset);\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        // We check that the amount is less than or equal to supplyCurrent\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // We want to know the user\u0027s withdrawCapacity, denominated in the asset\n        // Customer\u0027s withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply.\n        // Note that, even though the customer is withdrawing, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // failure\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n        supplyBalance.principal = localResults.userSupplyUpdated;\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n        \n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Gets the user\u0027s account liquidity and account shortfall balances. This includes\n     *      any accumulated interest thus far but does NOT actually update anything in\n     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n     */\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n        Error err;\n        uint sumSupplyValuesMantissa;\n        uint sumBorrowValuesMantissa;\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        Exp memory result;\n\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // if sumSupplies \u003c sumBorrows, then the user is under collateralized and has account shortfall.\n        // else the user meets the collateral ratio and has account liquidity.\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n            // accountShortfall = borrows - supplies\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n        } else {\n            // accountLiquidity = supplies - borrows\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n        }\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n     * TODO: To help save gas we could think about using the current Market.interestIndex\n     *       accumulate interest rather than calculating it\n     */\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n\n        /** By definition, all collateralMarkets are those that contribute to the user\u0027s\n         * liquidity and shortfall so we need only loop through those markets.\n         * To handle avoiding intermediate negative results, we will sum all the user\u0027s\n         * supply balances and borrow balances (with collateral ratio) separately and then\n         * subtract the sums at the end.\n         */\n\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n        localResults.sumSupplies = Exp({mantissa: 0});\n        localResults.sumBorrows = Exp({mantissa: 0});\n        Error err; // Re-used for all intermediate errors\n        localResults.collateralMarketsLength = collateralMarkets.length;\n\n        for (uint i = 0; i \u003c localResults.collateralMarketsLength; i++) {\n            localResults.assetAddress = collateralMarkets[i];\n            Market storage currentMarket = markets[localResults.assetAddress];\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n\n            if (supplyBalance.principal \u003e 0) {\n                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // We have the user\u0027s supply balance with interest so let\u0027s multiply by the asset price to get the total value\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of supplies\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n\n            if (borrowBalance.principal \u003e 0) {\n                // We perform a similar actions to get the user\u0027s borrow balance\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of borrows\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n        }\n\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n     *          sum ETH value of supplies scaled by 10e18,\n     *          sum ETH value of borrows scaled by 10e18)\n     */\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n\n            return (uint(err), 0, 0);\n        }\n\n        return (0, supplyValue, borrowValue);\n    }\n\n    /**\n     * @notice Users repay borrowed assets from their own address to the protocol.\n     * @param asset The market asset to repay\n     * @param amount The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(address asset, uint amount) public payable returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n        }\n        PayBorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n        Error err;\n        uint rateCalculationResultCode;\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        uint reimburseAmount;\n        // If the user specifies -1 amount to repay (“max”), repayAmount =\u003e\n        // the lesser of the senders ERC-20 balance and borrowCurrent\n        if (asset != wethAddress) {\n            if (amount == uint(-1)) {\n                localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n            } else {\n                localResults.repayAmount = amount;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (amount \u003e localResults.userBorrowCurrent) {\n                localResults.repayAmount = localResults.userBorrowCurrent;\n                (err, reimburseAmount) = sub(amount,localResults.userBorrowCurrent); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.repayAmount = amount;\n            }\n        }\n\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n        // Note: this checks that repayAmount is less than borrowCurrent\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail gracefully if asset is not approved or has insufficient balance\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnPublic contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the customer is paying some of their borrow, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnPublic contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,localResults.repayAmount);\n                //Repay excess funds\n                if(reimburseAmount \u003e 0){\n                    revertEtherToUser(msg.sender,reimburseAmount);\n                }\n                if(supplyError != 0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                } \n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n        \n        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice users repay all or some of an underwater borrow and receive collateral\n     * @param targetAccount The account whose borrow should be liquidated\n     * @param assetBorrow The market asset to repay\n     * @param assetCollateral The borrower\u0027s market asset to receive in exchange\n     * @param requestedAmountClose The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) payable public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n        }\n        LiquidateLocalVars memory localResults;\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n        // We\u0027ll use localResults.liquidator inside this function for clarity vs using msg.sender.\n        localResults.targetAccount = targetAccount;\n        localResults.assetBorrow = assetBorrow;\n        localResults.liquidator = msg.sender;\n        localResults.assetCollateral = assetCollateral;\n\n        Market storage borrowMarket = markets[assetBorrow];\n        Market storage collateralMarket = markets[assetCollateral];\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n\n        // Liquidator might already hold some of the collateral asset\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n        Error err; // re-used for all intermediate errors\n\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n        if(err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n        }\n\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n        assert(err == Error.NO_ERROR);\n\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Liquidator may or may not already have some collateral asset.\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We update the protocol\u0027s totalSupply for assetCollateral in 2 steps, first by adding target user\u0027s accumulated\n        // interest and then by adding the liquidator\u0027s accumulated interest.\n\n        // Step 1 of 2: We add the target user\u0027s supplyCurrent and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the target user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Step 2 of 2: We add the liquidator\u0027s supplyCurrent of collateral asset and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the calling user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n        // This is equal to the lesser of\n        // 1. borrowCurrent; (already calculated)\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n        // discountedRepayToEvenAmount=\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n        // 3. discountedBorrowDenominatedCollateral\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n        (err, localResults.discountedBorrowDenominatedCollateral) =\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n        }\n\n        if (borrowMarket.isSupported) {\n            // Market is supported, so we calculate item 2 from above.\n            (err, localResults.discountedRepayToEvenAmount) =\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n            }\n\n            // We need to do a two-step min to select from all 3 values\n            // min1\u00263 = min(item 1, item 3)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n\n            // min1\u00263\u00262 = min(min1\u00263, 2)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n        } else {\n            // Market is not supported, so we don\u0027t need to calculate item 2.\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n        }\n\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (assetBorrow != wethAddress) {\n            if (requestedAmountClose == uint(-1)) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (requestedAmountClose \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n                (err, localResults.reimburseAmount) = sub(requestedAmountClose,localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        }\n\n        // From here on, no more use of `requestedAmountClose`\n\n        // Verify closeBorrowAmount_TargetUnderwaterAsset \u003c= maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n        }\n\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n        }\n\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n        // Fail gracefully if asset is not approved or has insufficient balance\n        if(assetBorrow != wethAddress) { // WETH is supplied to AlkemiEarnPublic contract in case of ETH automatically\n            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We are going to repay the target user\u0027s borrow using the calling user\u0027s funds\n        // We update the protocol\u0027s totalBorrow for assetBorrow, by subtracting the target user\u0027s prior checkpointed balance,\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset \u003c= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can\u0027t underflow\n        assert(err == Error.NO_ERROR);\n\n        // We calculate the protocol\u0027s totalBorrow for assetBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n        // (Please note that we don\u0027t need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don\u0027t recalculate it.\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        // Now we look at collateral. We calculated target user\u0027s accumulated supply balance and the supply index above.\n        // Now we need to calculate the borrow index.\n        // We don\u0027t need to calculate new rates for the collateral asset because we have not changed utilization:\n        //  - accumulating interest on the target user\u0027s collateral does not change cash or borrows\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        // We checkpoint the target user\u0027s assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // The sub won\u0027t underflow because because seizeSupplyAmount_TargetCollateralAsset \u003c= target user\u0027s collateral balance\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n        assert (err == Error.NO_ERROR);\n\n        // We checkpoint the liquidating user\u0027s assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // We can\u0027t overflow here because if this would overflow, then we would have already overflowed above and failed\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n        assert (err == Error.NO_ERROR);\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n        if(assetBorrow != wethAddress) { // WETH is supplied to AlkemiEarnPublic contract in case of ETH automatically\n            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n            }\n        } else {\n            uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            //Repay excess funds\n                if(localResults.reimburseAmount \u003e 0){\n                    revertEtherToUser(localResults.liquidator,localResults.reimburseAmount);\n                }\n            if(supplyError !=0 ){\n                return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n            }\n        }\n\n        // Save borrow market updates\n        borrowMarket.blockNumber = getBlockNumber();\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n        // borrowMarket.totalSupply does not need to be updated\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        // Save collateral market updates\n        // We didn\u0027t calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n        collateralMarket.blockNumber = getBlockNumber();\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n\n        // Save user updates\n\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n        \n        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n\n        emitLiquidationEvent(localResults);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n     */\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n        emit BorrowLiquidated(localResults.targetAccount,\n            localResults.assetBorrow,\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n            localResults.liquidator,\n            localResults.assetCollateral,\n            localResults.startingSupplyBalance_TargetCollateralAsset,\n            localResults.currentSupplyBalance_TargetCollateralAsset,\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\n    }\n\n    /**\n     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n     *      If the market isn\u0027t supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n     */\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n        Error err;\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n        Exp memory accountShortfall_TargetUser;\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n        Exp memory discountedPrice_UnderwaterAsset;\n        Exp memory rawResult;\n\n        // we calculate the target user\u0027s shortfall, denominated in Ether, that the user is below the collateral ratio\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n        // discountedCollateralRatioMinusOne \u003c collateralRatio\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can\u0027t overflow either\n        assert(err == Error.NO_ERROR);\n\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n        // It\u0027s theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n    /**\n     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n     */\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n        Error err;\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n        Exp memory rawResult;\n\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n     */\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n\n        // re-used for all intermediate errors\n        Error err;\n\n        // (1+liquidationDiscount)\n        Exp memory liquidationMultiplier;\n\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n        // or, expanded:\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n        Exp memory finalNumerator;\n\n        // finalNumerator / priceCollateral\n        Exp memory rawResult;\n\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        // liquidation discount will be enforced \u003c 1, so 1 + liquidationDiscount can\u0027t overflow.\n        assert(err == Error.NO_ERROR);\n\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param asset The market asset to borrow\n     * @param amount The amount to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(address asset, uint amount) public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n        }\n        BorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n\n        Error err;\n        uint rateCalculationResultCode;\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n        }\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Calculate origination fee.\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n        }\n        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow with fee\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // Check customer liquidity\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // Would the customer have a shortfall after this borrow (including origination fee)?\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] \u003e accountLiquidity`\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // Fail gracefully if protocol has insufficient cash\n        localResults.currentCash = getCash(asset);\n        // We need to calculate what the updated cash will be after we transfer out to the user\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            // Note: we ignore error here and call this token insufficient cash\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n\n        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n        uint originationFeeRepaid = 0;\n        if (originationFeeBalance[user][asset] != 0){\n            if (amount \u003c originationFeeBalance[user][asset]) {\n                originationFeeRepaid = amount;\n            } else {\n                originationFeeRepaid = originationFeeBalance[user][asset];\n            }\n            Balance storage balance = supplyBalances[admin][asset];\n\n            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n            Error err; // Re-used for every function call that includes an Error in its return value(s).\n\n            originationFeeBalance[user][asset] -= originationFeeRepaid;\n\n            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n\n            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n\n            // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n\n            // Save market updates\n            markets[asset].totalSupply =  localResults.newTotalSupply;\n\n            // Save user updates\n            localResults.startingBalance = balance.principal;\n            balance.principal = localResults.userSupplyUpdated;\n            balance.interestIndex = newSupplyIndex;\n\n            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n        }\n    }\n}"},"AlkemiEarnVerified.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./ChainLink.sol\";\nimport \"./AlkemiWETH.sol\";\n\ncontract AlkemiEarnVerified is Exponential, SafeToken {\n\n    uint internal initialInterestIndex;\n    uint internal defaultOriginationFee; \n    uint internal defaultCollateralRatio;\n    uint internal defaultLiquidationDiscount;\n\n    uint internal minimumCollateralRatioMantissa;\n    uint internal maximumLiquidationDiscountMantissa;\n    bool public initializationDone; // To make sure initializer is called only once\n\n    /**\n     * @notice `AlkemiEarnVerified` is the core contract\n     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n     * @notice Hence this contract has an \u0027initializer\u0027 in place of a \u0027constructor\u0027\n     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n     */\n    function initializer() public {\n        if(initializationDone == false) {\n            initializationDone = true;\n            admin = msg.sender;\n            initialInterestIndex = 10 ** 18;\n            defaultOriginationFee = (10 ** 15); // default is 0.1%\n            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n            originationFee = Exp({mantissa: defaultOriginationFee});\n            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n            // oracle must be configured via _setOracle\n        }\n    }\n\n    /**\n     * @notice Do not pay directly into AlkemiEarnVerified, please use `supply`.\n     */\n    function() payable public {\n        revert();\n    }\n\n    /**\n     * @dev pending Administrator for this contract.\n     */\n    address public pendingAdmin;\n\n    /**\n     * @dev Administrator for this contract. Initially set in constructor, but can\n     *      be changed by the admin itself.\n     */\n    address public admin;\n\n    /**\n     * @dev Managers for this contract with limited permissions. Can\n     *      be changed by the admin.\n     */\n    mapping (address =\u003e bool) public managers;\n\n    /**\n     * @dev Account allowed to set oracle prices for this contract. Initially set\n     *      in constructor, but can be changed by the admin.\n     */\n    address public oracle;\n\n    /**\n     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n     */\n    ChainLink priceOracle;\n\n    /**\n     * @dev Container for customer balance information written to storage.\n     *\n     *      struct Balance {\n     *        principal = customer total balance with accrued interest after applying the customer\u0027s most recent balance-changing action\n     *        interestIndex = the total interestIndex as calculated after applying the customer\u0027s most recent balance-changing action\n     *      }\n     */\n    struct Balance {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for supplies\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public supplyBalances;\n\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public borrowBalances;\n\n\n    /**\n     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n     *\n     *      struct Market {\n     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n     *         blockNumber = when the other values in this struct were calculated\n     *         totalSupply = total amount of this asset supplied (in asset wei)\n     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n     *     }\n     */\n    struct Market {\n        bool isSupported;\n        uint blockNumber;\n        InterestRateModel interestRateModel;\n\n        uint totalSupply;\n        uint supplyRateMantissa;\n        uint supplyIndex;\n\n        uint totalBorrows;\n        uint borrowRateMantissa;\n        uint borrowIndex;\n    }\n\n    /**\n     * @dev wethAddress to hold the WETH token contract address\n     * set using setWethAddress function\n     */\n    address public wethAddress;\n\n    /**\n     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n     */\n    AlkemiWETH public WETHContract;\n\n    /**\n     * @dev map: assetAddress -\u003e Market\n     */\n    mapping(address =\u003e Market) public markets;\n\n    /**\n     * @dev list: collateralMarkets\n     */\n    address[] public collateralMarkets;\n\n    /**\n     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n     *      is initially set in the constructor, but can be changed by the admin.\n     */\n    Exp public collateralRatio;\n\n    /**\n     * @dev originationFee for new borrows.\n     *\n     */\n    Exp public originationFee;\n\n    /**\n     * @dev liquidationDiscount for collateral when liquidating borrows\n     *\n     */\n    Exp public liquidationDiscount;\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    /**\n     * @dev Mapping to identify the list of KYC Admins\n     */\n    mapping(address=\u003ebool) private KYCAdmins;\n    /**\n     * @dev Mapping to identify the list of customers with verified KYC\n     */\n    mapping(address=\u003ebool) private customersWithKYC;\n\n    /**\n     * @dev Mapping to identify the list of customers with Liquidator roles\n     */\n    mapping(address=\u003ebool) private liquidators;\n\n    /**\n     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n    struct SupplyLocalVars {\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n    }\n\n    /**\n     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n\n    struct WithdrawLocalVars {\n        uint withdrawAmount;\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfWithdrawal;\n        uint withdrawCapacity;\n    }\n\n    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n    struct AccountValueLocalVars {\n        address assetAddress;\n        uint collateralMarketsLength;\n\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        Exp supplyTotalValue;\n        Exp sumSupplies;\n\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        Exp borrowTotalValue;\n        Exp sumBorrows;\n    }\n\n    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n    struct PayBorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint repayAmount;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n    }\n\n    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n    struct BorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint borrowAmountWithFee;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfBorrowAmountWithFee;\n    }\n\n    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n    struct LiquidateLocalVars {\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n        address targetAccount;\n        address assetBorrow;\n        address liquidator;\n        address assetCollateral;\n\n        // borrow index and supply index are global to the asset, not specific to the user\n        uint newBorrowIndex_UnderwaterAsset;\n        uint newSupplyIndex_UnderwaterAsset;\n        uint newBorrowIndex_CollateralAsset;\n        uint newSupplyIndex_CollateralAsset;\n\n        // the target borrow\u0027s full balance with accumulated interest\n        uint currentBorrowBalance_TargetUnderwaterAsset;\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\n\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\n\n        uint startingBorrowBalance_TargetUnderwaterAsset;\n        uint startingSupplyBalance_TargetCollateralAsset;\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\n\n        uint currentSupplyBalance_TargetCollateralAsset;\n        uint updatedSupplyBalance_TargetCollateralAsset;\n\n        // If liquidator already has a balance of collateralAsset, we will accumulate\n        // interest on it before transferring seized collateral from the borrower.\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\n        // This will be the liquidator\u0027s accumulated balance of collateral asset before the liquidation (if any)\n        // plus the amount seized from the borrower.\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n\n        uint newTotalSupply_ProtocolCollateralAsset;\n        uint currentCash_ProtocolUnderwaterAsset;\n        uint updatedCash_ProtocolUnderwaterAsset;\n\n        // cash does not change for collateral asset\n\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n\n        // Why no variables for the interest rates for the collateral asset?\n        // We don\u0027t need to calculate new rates for the collateral asset since neither cash nor borrows change\n\n        uint discountedRepayToEvenAmount;\n\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n        uint discountedBorrowDenominatedCollateral;\n\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        uint closeBorrowAmount_TargetUnderwaterAsset;\n        uint seizeSupplyAmount_TargetCollateralAsset;\n\n        Exp collateralPrice;\n        Exp underwaterAssetPrice;\n\n        uint reimburseAmount;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e originationFeeBalance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e uint)) public originationFeeBalance;\n\n    /**\n     * @dev Event emitted on successful addition of Weth Address\n     */\n    event WETHAddressSet(address wethAddress);\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event LiquidatorAdded(address Liquidator);\n    event LiquidatorRemoved(address Liquidator);\n\n    /**\n     * @dev emitted when a supply is received\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a origination fee supply is received as admin\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n    /**\n     * @dev emitted when a supply is withdrawn\n     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a new borrow is taken\n     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n     */\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is repaid\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is liquidated\n     *      targetAccount = user whose borrow was liquidated\n     *      assetBorrow = asset borrowed\n     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountRepaid = amount of borrow repaid\n     *      liquidator = account requesting the liquidation\n     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountSeized = amount of collateral seized by liquidator\n     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n     */\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    /**\n     * @dev emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev newOracle - address of new oracle\n     */\n    event NewOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev emitted when new market is supported by admin\n     */\n    event SupportedMarket(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when risk parameters are changed by admin\n     */\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n\n    /**\n     * @dev emitted when origination fee is changed by admin\n     */\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n\n    /**\n     * @dev emitted when market has new interest rate model set\n     */\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when admin withdraws equity\n     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n     */\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n\n    /**\n     * @dev emitted when a supported market is suspended by admin\n     */\n    event SuspendedMarket(address asset);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev KYC Integration\n     */\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event KYCAdminAdded(address KYCAdmin);\n    event KYCAdminRemoved(address KYCAdmin);\n    event KYCCustomerAdded(address KYCCustomer);\n    event KYCCustomerRemoved(address KYCCustomer);\n\n    /**\n     * @dev Modifier to check if the caller of the function is a manager or owner\n     */\n    modifier onlyAdminOrManager {\n        // Check caller = KYCadmin\n        require(msg.sender == admin || managers[msg.sender],\"Only owner or manager can perform operation\");\n        _;\n    }\n\n    /**\n     * @dev Function to emit fail event to frontend\n     */\n    function emitError(Error error, FailureInfo failure) private returns(uint) {\n        return fail(error, failure);\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is a KYC Admin\n     */\n    modifier isKYCAdmin {\n        // Check caller = KYCadmin\n        if (!KYCAdmins[msg.sender]) {\n            emitError(Error.KYC_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_CHECK_FAILED);\n        } else {\n            require(KYCAdmins[msg.sender],\"Operation can only be performed by a KYC Admin\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is KYC verified\n     */\n    modifier isKYCVerifiedCustomer {\n        // Check caller = KYCVerifiedCustomer\n        if (!customersWithKYC[msg.sender]) {\n            revertEtherToUser(msg.sender,msg.value);\n            emitError(Error.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED, FailureInfo.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED);\n        } else {\n            require(customersWithKYC[msg.sender],\"Customer is not KYC Verified\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add KYC Admins\n     */\n    function addKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = true;\n        emit KYCAdminAdded(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove KYC Admins\n     */\n    function removeKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = false;\n        emit KYCAdminRemoved(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to add KYC Customers\n     */\n    function addCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = true;\n        emit KYCCustomerAdded(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to remove KYC Customers\n     */\n    function removeCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = false;\n        emit KYCCustomerRemoved(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch KYC verification status of a customer\n     */\n    function verifyKYC(address customer) public view returns(bool) {\n        return customersWithKYC[customer];\n    }\n\n    /**\n     * @dev Function to fetch KYC Admin status of an admin\n     */\n    function checkKYCAdmin(address _KYCAdmin) public view returns(bool) {\n        return KYCAdmins[_KYCAdmin];\n    }\n\n    /**\n     * @dev Liquidator Integration\n     */\n\n    /**\n     * @dev Modifier to check if the caller of the function is a Liquidator\n     */\n    modifier isLiquidator {\n        // Check caller = Liquidator\n        if (!liquidators[msg.sender]) {\n            emitError(Error.LIQUIDATOR_CHECK_FAILED, FailureInfo.LIQUIDATOR_CHECK_FAILED);\n        } else {\n            require(liquidators[msg.sender],\"Customer is not a Liquidator\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add Liquidators\n     */\n    function addLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = true;\n        emit LiquidatorAdded(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove Liquidators\n     */\n    function removeLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = false;\n        emit LiquidatorRemoved(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch Liquidator status of a customer\n     */\n    function verifyLiquidator(address liquidator) public view returns(bool) {\n        return liquidators[liquidator];\n    }\n\n    /**\n     * @dev Simple function to calculate min between two numbers.\n     */\n    function min(uint a, uint b) pure internal returns (uint) {\n        if (a \u003c b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *      This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n     *      Note: this will not add the asset if it already exists.\n     */\n    function addCollateralMarket(address asset) internal {\n        for (uint i = 0; i \u003c collateralMarkets.length; i++) {\n            if (collateralMarkets[i] == asset) {\n                return;\n            }\n        }\n\n        collateralMarkets.push(asset);\n    }\n\n    /**\n     * @notice return the number of elements in `collateralMarkets`\n     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n     * @return the length of `collateralMarkets`\n     */\n    function getCollateralMarketsLength() public view returns (uint) {\n        return collateralMarkets.length;\n    }\n\n    /**\n     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n     */\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n\n        // Get the block delta\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        // Scale the interest rate times number of blocks\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n        if (err2 != Error.NO_ERROR) {\n            return (err2, 0);\n        }\n\n        // Then scale that accumulated interest by the old interest index to get the new interest index\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n        if (err3 != Error.NO_ERROR) {\n            return (err3, 0);\n        }\n\n        // Finally, truncate the interest index. This works only if interest index starts large enough\n        // that is can be accurately represented with a whole number.\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n    }\n\n    /**\n     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n     *      This is defined as: `The user\u0027s last balance checkpoint is multiplied by the currentSupplyIndex\n     *      value and divided by the user\u0027s checkpoint index value`\n     *\n     *      TODO: Is there a way to handle this that is less likely to overflow?\n     */\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n        if (startingBalance == 0) {\n            // We are accumulating interest on any previous balance; if there\u0027s no previous balance, then there is\n            // nothing to accumulate.\n            return (Error.NO_ERROR, 0);\n        }\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return div(balanceTimesIndex, interestIndexStart);\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset.\n     */\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n     */\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory scaledPrice;\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        // Now, multiply the assetValue by the collateral ratio\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        // Get the price for the given asset amount\n        return mulScalar(scaledPrice, assetAmount);\n    }\n\n    /**\n     * @dev Calculates the origination fee added to a given borrowAmount\n     *      This is simply `(1 + originationFee) * borrowAmount`\n     *\n     *      TODO: Track at what magnitude this fee rounds down to zero?\n     */\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n        // When origination fee is zero, the amount with fee is simply equal to the amount\n        if (isZeroExp(originationFee)) {\n            return (Error.NO_ERROR, borrowAmount);\n        }\n\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n    }\n\n    /**\n     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n     * @param asset asset whose price should be fetched\n     */\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n        if (oracle == address(0)) {\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n        }\n\n        uint priceMantissa = priceOracle.getAssetPrice(asset);\n\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n    }\n\n    /**\n     * @notice Reads scaled price of specified asset from the price oracle\n     * @dev Reads scaled price of specified asset from the price oracle.\n     *      The plural name is to match a previous storage mapping that this function replaced.\n     * @param asset Asset whose price should be retrieved\n     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return 0;\n        }\n        return result.mantissa;\n    }\n\n    /**\n     * @dev Gets the amount of the specified asset given the specified Eth value\n     *      ethValue / oraclePrice = assetAmountWei\n     *      If there\u0027s no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n     */\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory assetAmount;\n\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, assetAmount) = divExp(ethValue, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(assetAmount));\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller = pendingAdmin\n        // msg.sender can\u0027t be zero\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAdmin = admin;\n        // Store admin = pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = 0;\n\n        emit NewAdmin(oldAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new oracle, who can set asset prices\n     * @dev Admin function to change oracle\n     * @param newOracle New oracle address\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOracle(address newOracle) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n        }\n\n        // Verify contract at newOracle address supports assetPrices call.\n        // This will revert if it doesn\u0027t.\n        // ChainLink priceOracleTemp = ChainLink(newOracle);\n        // priceOracleTemp.getAssetPrice(address(0));\n\n        address oldOracle = oracle;\n\n        // Store oracle = newOracle\n        oracle = newOracle;\n        // Initialize the Chainlink contract in priceOracle\n        priceOracle = ChainLink(newOracle);\n\n        emit NewOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice returns the liquidity for given account.\n     *         a positive result indicates ability to borrow, whereas\n     *         a negative result indicates a shortfall which may be liquidated\n     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n     *      note: this includes interest trued up on all balances\n     * @param account the account to examine\n     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n     */\n    function getAccountLiquidity(address account) public view returns (int) {\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n        require(err == Error.NO_ERROR);\n\n        if (isZeroExp(accountLiquidity)) {\n            return -1 * int(truncate(accountShortfall));\n        } else {\n            return int(truncate(accountLiquidity));\n        }\n    }\n\n    /**\n     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose supply balance belonging to `account` should be checked\n     * @return uint supply balance on success, throws on failed assertion otherwise\n     */\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[account][asset];\n\n        // Calculate the newSupplyIndex, needed to calculate user\u0027s supplyCurrent\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n        require(err == Error.NO_ERROR);\n\n        return userSupplyCurrent;\n    }\n\n    /**\n     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n     * @return uint borrow balance on success, throws on failed assertion otherwise\n     */\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[account][asset];\n\n        // Calculate the newBorrowIndex, needed to calculate user\u0027s borrowCurrent\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n        require(err == Error.NO_ERROR);\n\n        return userBorrowCurrent;\n    }\n\n\n    /**\n     * @notice Supports a given market (asset) for use\n     * @dev Admin function to add support for a market\n     * @param asset Asset to support; MUST already have a non-zero price set\n     * @param interestRateModel InterestRateModel to use for the asset\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        // Append asset to collateralAssets if not set\n        addCollateralMarket(asset);\n\n        // Set market isSupported to true\n        markets[asset].isSupported = true;\n\n        // Default supply and borrow index to 1e18\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n\n        emit SupportedMarket(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Suspends a given *supported* market (asset) from use.\n     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n     * @dev Admin function to suspend a market\n     * @param asset Asset to suspend\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _suspendMarket(address asset) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n        }\n\n        // If the market is not configured at all, we don\u0027t want to add any configuration for it.\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n        // has already been marked as unsupported. We can just return without doing anything.\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n        if (!markets[asset].isSupported) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // If we get here, we know market is configured and is supported, so set isSupported to false\n        markets[asset].isSupported = false;\n\n        emit SuspendedMarket(asset);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n     * @dev Owner function to set the risk parameters\n     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be \u003c= 0.1 and must be less than (descaled collateral ratio minus 1)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n        }\n\n        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n\n        Error err;\n        Exp memory newLiquidationDiscountPlusOne;\n\n        // Make sure new collateral ratio value is not below minimum value\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n        // C \u003c L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Save current values so we can emit them in log.\n        Exp memory oldCollateralRatio = collateralRatio;\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\n\n        // Store new values\n        collateralRatio = newCollateralRatio;\n        liquidationDiscount = newLiquidationDiscount;\n\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the origination fee (which is a multiplier on new borrows)\n     * @dev Owner function to set the origination fee\n     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n        }\n\n        // Save current value so we can emit it in log.\n        Exp memory oldOriginationFee = originationFee;\n\n        originationFee = Exp({mantissa: originationFeeMantissa});\n\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the interest rate model for a given market\n     * @dev Admin function to set interest rate model\n     * @param asset Asset to support\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        emit SetMarketInterestRateModel(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` \u003c= equity. Equity= cash - (supply + borrows)\n     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount \u003c= cash - (supply + borrows)\n     * @param asset asset whose equity should be withdrawn\n     * @param amount amount of equity to withdraw; must not exceed equity available\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n        }\n\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n        uint cash = getCash(asset);\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n        if (err0 != Error.NO_ERROR) {\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n        }\n\n        if (amount \u003e equity) {\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset out of the protocol to the admin\n            Error err2 = doTransferOut(asset, admin, amount);\n            if (err2 != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n        emit EquityWithdrawn(asset, equity, amount, admin);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Set WETH token contract address\n     * @param wethContractAddress Enter the WETH token address\n     */\n    function setWethAddress(address wethContractAddress) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n        }\n        wethAddress = wethContractAddress;\n        WETHContract = AlkemiWETH(wethAddress);\n        emit WETHAddressSet(wethContractAddress);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n     * @return errors if any\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n        user; // To silence the warning of unused local variable\n        if(wethAddress != address(0)){\n            WETHContract.deposit.value(etherAmount)();\n            return uint(Error.NO_ERROR);\n        }\n        else {\n            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n        }\n    }\n\n    /**\n     * @dev Revert Ether paid by user back to user\u0027s account in case transaction fails due to some other reason\n     * @param etherAmount Amount of ether to be sent back to user\n     * @param user User account address\n     */\n    function revertEtherToUser(address user, uint etherAmount) internal {\n        if(etherAmount \u003e 0){\n            user.transfer(etherAmount);\n        }\n    }\n\n    /**\n     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n     * @dev add amount of supported asset to msg.sender\u0027s account\n     * @param asset The market asset to supply\n     * @param amount The amount to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function supply(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage balance = supplyBalances[msg.sender][asset];\n\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n        }\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n            // Fail gracefully if asset is not approved or has insufficient balance\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n        balance.principal = localResults.userSupplyUpdated;\n        balance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice withdraw `amount` of `ether` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `ether` from msg.sender\u0027s account to msg.sender\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n            WETHContract.withdraw(user,etherAmount);\n            return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice send Ether from contract to a user\n     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n     */\n    function sendEtherToUser(address user, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n        }\n        user.transfer(amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraw `amount` of `asset` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `asset` from msg.sender\u0027s account to msg.sender\n     * @param asset The market asset to withdraw\n     * @param requestedAmount The amount to withdraw (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function withdraw(address asset, uint requestedAmount) public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // We calculate the user\u0027s accountLiquidity and accountShortfall.\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount =\u003e the lesser of withdrawCapacity and supplyCurrent\n        if (requestedAmount == uint(-1)) {\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n            }\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n        } else {\n            localResults.withdrawAmount = requestedAmount;\n        }\n\n        // From here on we should NOT use requestedAmount.\n\n        // Fail gracefully if protocol has insufficient cash\n        // If protocol has insufficient cash, the sub operation will underflow.\n        localResults.currentCash = getCash(asset);\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        // We check that the amount is less than or equal to supplyCurrent\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // We want to know the user\u0027s withdrawCapacity, denominated in the asset\n        // Customer\u0027s withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply.\n        // Note that, even though the customer is withdrawing, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // failure\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n        supplyBalance.principal = localResults.userSupplyUpdated;\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n        \n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Gets the user\u0027s account liquidity and account shortfall balances. This includes\n     *      any accumulated interest thus far but does NOT actually update anything in\n     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n     */\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n        Error err;\n        uint sumSupplyValuesMantissa;\n        uint sumBorrowValuesMantissa;\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        Exp memory result;\n\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // if sumSupplies \u003c sumBorrows, then the user is under collateralized and has account shortfall.\n        // else the user meets the collateral ratio and has account liquidity.\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n            // accountShortfall = borrows - supplies\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n        } else {\n            // accountLiquidity = supplies - borrows\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n        }\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n     * TODO: To help save gas we could think about using the current Market.interestIndex\n     *       accumulate interest rather than calculating it\n     */\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n\n        /** By definition, all collateralMarkets are those that contribute to the user\u0027s\n         * liquidity and shortfall so we need only loop through those markets.\n         * To handle avoiding intermediate negative results, we will sum all the user\u0027s\n         * supply balances and borrow balances (with collateral ratio) separately and then\n         * subtract the sums at the end.\n         */\n\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n        localResults.sumSupplies = Exp({mantissa: 0});\n        localResults.sumBorrows = Exp({mantissa: 0});\n        Error err; // Re-used for all intermediate errors\n        localResults.collateralMarketsLength = collateralMarkets.length;\n\n        for (uint i = 0; i \u003c localResults.collateralMarketsLength; i++) {\n            localResults.assetAddress = collateralMarkets[i];\n            Market storage currentMarket = markets[localResults.assetAddress];\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n\n            if (supplyBalance.principal \u003e 0) {\n                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // We have the user\u0027s supply balance with interest so let\u0027s multiply by the asset price to get the total value\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of supplies\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n\n            if (borrowBalance.principal \u003e 0) {\n                // We perform a similar actions to get the user\u0027s borrow balance\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of borrows\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n        }\n\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n     *          sum ETH value of supplies scaled by 10e18,\n     *          sum ETH value of borrows scaled by 10e18)\n     */\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n\n            return (uint(err), 0, 0);\n        }\n\n        return (0, supplyValue, borrowValue);\n    }\n\n    /**\n     * @notice Users repay borrowed assets from their own address to the protocol.\n     * @param asset The market asset to repay\n     * @param amount The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(address asset, uint amount) public payable returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n        }\n        PayBorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n        Error err;\n        uint rateCalculationResultCode;\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        uint reimburseAmount;\n        // If the user specifies -1 amount to repay (“max”), repayAmount =\u003e\n        // the lesser of the senders ERC-20 balance and borrowCurrent\n        if (asset != wethAddress) {\n            if (amount == uint(-1)) {\n                localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n            } else {\n                localResults.repayAmount = amount;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (amount \u003e localResults.userBorrowCurrent) {\n                localResults.repayAmount = localResults.userBorrowCurrent;\n                (err, reimburseAmount) = sub(amount,localResults.userBorrowCurrent); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.repayAmount = amount;\n            }\n        }\n\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n        // Note: this checks that repayAmount is less than borrowCurrent\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail gracefully if asset is not approved or has insufficient balance\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the customer is paying some of their borrow, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,localResults.repayAmount);\n                //Repay excess funds\n                if(reimburseAmount \u003e 0){\n                    revertEtherToUser(msg.sender,reimburseAmount);\n                }\n                if(supplyError != 0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                } \n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n        \n        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice users repay all or some of an underwater borrow and receive collateral\n     * @param targetAccount The account whose borrow should be liquidated\n     * @param assetBorrow The market asset to repay\n     * @param assetCollateral The borrower\u0027s market asset to receive in exchange\n     * @param requestedAmountClose The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) payable public isLiquidator returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n        }\n        LiquidateLocalVars memory localResults;\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n        // We\u0027ll use localResults.liquidator inside this function for clarity vs using msg.sender.\n        localResults.targetAccount = targetAccount;\n        localResults.assetBorrow = assetBorrow;\n        localResults.liquidator = msg.sender;\n        localResults.assetCollateral = assetCollateral;\n\n        Market storage borrowMarket = markets[assetBorrow];\n        Market storage collateralMarket = markets[assetCollateral];\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n\n        // Liquidator might already hold some of the collateral asset\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n        Error err; // re-used for all intermediate errors\n\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n        if(err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n        }\n\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n        assert(err == Error.NO_ERROR);\n\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Liquidator may or may not already have some collateral asset.\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We update the protocol\u0027s totalSupply for assetCollateral in 2 steps, first by adding target user\u0027s accumulated\n        // interest and then by adding the liquidator\u0027s accumulated interest.\n\n        // Step 1 of 2: We add the target user\u0027s supplyCurrent and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the target user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Step 2 of 2: We add the liquidator\u0027s supplyCurrent of collateral asset and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the calling user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n        // This is equal to the lesser of\n        // 1. borrowCurrent; (already calculated)\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n        // discountedRepayToEvenAmount=\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n        // 3. discountedBorrowDenominatedCollateral\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n        (err, localResults.discountedBorrowDenominatedCollateral) =\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n        }\n\n        if (borrowMarket.isSupported) {\n            // Market is supported, so we calculate item 2 from above.\n            (err, localResults.discountedRepayToEvenAmount) =\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n            }\n\n            // We need to do a two-step min to select from all 3 values\n            // min1\u00263 = min(item 1, item 3)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n\n            // min1\u00263\u00262 = min(min1\u00263, 2)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n        } else {\n            // Market is not supported, so we don\u0027t need to calculate item 2.\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n        }\n\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (assetBorrow != wethAddress) {\n            if (requestedAmountClose == uint(-1)) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (requestedAmountClose \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n                (err, localResults.reimburseAmount) = sub(requestedAmountClose,localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        }\n\n        // From here on, no more use of `requestedAmountClose`\n\n        // Verify closeBorrowAmount_TargetUnderwaterAsset \u003c= maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n        }\n\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n        }\n\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n        // Fail gracefully if asset is not approved or has insufficient balance\n        if(assetBorrow != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We are going to repay the target user\u0027s borrow using the calling user\u0027s funds\n        // We update the protocol\u0027s totalBorrow for assetBorrow, by subtracting the target user\u0027s prior checkpointed balance,\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset \u003c= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can\u0027t underflow\n        assert(err == Error.NO_ERROR);\n\n        // We calculate the protocol\u0027s totalBorrow for assetBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n        // (Please note that we don\u0027t need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don\u0027t recalculate it.\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        // Now we look at collateral. We calculated target user\u0027s accumulated supply balance and the supply index above.\n        // Now we need to calculate the borrow index.\n        // We don\u0027t need to calculate new rates for the collateral asset because we have not changed utilization:\n        //  - accumulating interest on the target user\u0027s collateral does not change cash or borrows\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        // We checkpoint the target user\u0027s assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // The sub won\u0027t underflow because because seizeSupplyAmount_TargetCollateralAsset \u003c= target user\u0027s collateral balance\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n        assert (err == Error.NO_ERROR);\n\n        // We checkpoint the liquidating user\u0027s assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // We can\u0027t overflow here because if this would overflow, then we would have already overflowed above and failed\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n        assert (err == Error.NO_ERROR);\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n        if(assetBorrow != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == requestedAmountClose){\n                uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n                //Repay excess funds\n                if(localResults.reimburseAmount \u003e 0){\n                    revertEtherToUser(localResults.liquidator,localResults.reimburseAmount);\n                }\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }   \n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save borrow market updates\n        borrowMarket.blockNumber = getBlockNumber();\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n        // borrowMarket.totalSupply does not need to be updated\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        // Save collateral market updates\n        // We didn\u0027t calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n        collateralMarket.blockNumber = getBlockNumber();\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n\n        // Save user updates\n\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n        \n        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n\n        emitLiquidationEvent(localResults);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n     */\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n        emit BorrowLiquidated(localResults.targetAccount,\n            localResults.assetBorrow,\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n            localResults.liquidator,\n            localResults.assetCollateral,\n            localResults.startingSupplyBalance_TargetCollateralAsset,\n            localResults.currentSupplyBalance_TargetCollateralAsset,\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\n    }\n\n    /**\n     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n     *      If the market isn\u0027t supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n     */\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n        Error err;\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n        Exp memory accountShortfall_TargetUser;\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n        Exp memory discountedPrice_UnderwaterAsset;\n        Exp memory rawResult;\n\n        // we calculate the target user\u0027s shortfall, denominated in Ether, that the user is below the collateral ratio\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n        // discountedCollateralRatioMinusOne \u003c collateralRatio\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can\u0027t overflow either\n        assert(err == Error.NO_ERROR);\n\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n        // It\u0027s theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n    /**\n     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n     */\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n        Error err;\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n        Exp memory rawResult;\n\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n     */\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n\n        // re-used for all intermediate errors\n        Error err;\n\n        // (1+liquidationDiscount)\n        Exp memory liquidationMultiplier;\n\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n        // or, expanded:\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n        Exp memory finalNumerator;\n\n        // finalNumerator / priceCollateral\n        Exp memory rawResult;\n\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        // liquidation discount will be enforced \u003c 1, so 1 + liquidationDiscount can\u0027t overflow.\n        assert(err == Error.NO_ERROR);\n\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param asset The market asset to borrow\n     * @param amount The amount to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(address asset, uint amount) public isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n        }\n        BorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n\n        Error err;\n        uint rateCalculationResultCode;\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n        }\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Calculate origination fee.\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n        }\n        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow with fee\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // Check customer liquidity\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // Would the customer have a shortfall after this borrow (including origination fee)?\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] \u003e accountLiquidity`\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // Fail gracefully if protocol has insufficient cash\n        localResults.currentCash = getCash(asset);\n        // We need to calculate what the updated cash will be after we transfer out to the user\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            // Note: we ignore error here and call this token insufficient cash\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n\n        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n        uint originationFeeRepaid = 0;\n        if (originationFeeBalance[user][asset] != 0){\n            if (amount \u003c originationFeeBalance[user][asset]) {\n                originationFeeRepaid = amount;\n            } else {\n                originationFeeRepaid = originationFeeBalance[user][asset];\n            }\n            Balance storage balance = supplyBalances[admin][asset];\n\n            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n            Error err; // Re-used for every function call that includes an Error in its return value(s).\n\n            originationFeeBalance[user][asset] -= originationFeeRepaid;\n\n            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n\n            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n\n            // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n\n            // Save market updates\n            markets[asset].totalSupply =  localResults.newTotalSupply;\n\n            // Save user updates\n            localResults.startingBalance = balance.principal;\n            balance.principal = localResults.userSupplyUpdated;\n            balance.interestIndex = newSupplyIndex;\n\n            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n        }\n    }\n}"},"AlkemiRateModel.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./Exponential.sol\";\r\nimport \"./LiquidationChecker.sol\";\r\n\r\n/**\r\n  * @title  Earn Interest Rate Model\r\n  * @author ShiftForex\r\n  * @notice See Model here\r\n  */\r\n\r\ncontract AlkemiRateModel is Exponential, LiquidationChecker {\r\n\r\n    uint constant blocksPerYear = 2102400;\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    string public contractName;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"non-owner\");\r\n        _;\r\n    }\r\n\r\n    enum IRError {\r\n        NO_ERROR,\r\n        FAILED_TO_ADD_CASH_PLUS_BORROWS,\r\n        FAILED_TO_GET_EXP,\r\n        FAILED_TO_MUL_PRODUCT_TIMES_BORROW_RATE\r\n    }\r\n\r\n    event OwnerUpdate(address indexed owner, address indexed newOwner);\r\n    event LiquidatorUpdate(address indexed owner, address indexed newLiquidator, address indexed oldLiquidator);\r\n\r\n    Exp internal SpreadLow;\r\n    Exp internal BreakPointLow;\r\n    Exp internal ReserveLow;\r\n    Exp internal ReserveMid;\r\n    Exp internal SpreadMid;\r\n    Exp internal BreakPointHigh;\r\n    Exp internal ReserveHigh;\r\n    ExpNegative internal SpreadHigh;\r\n\r\n    Exp internal MinRateActual;\r\n    Exp internal HealthyMinURActual;\r\n    Exp internal HealthyMinRateActual;\r\n    Exp internal MaxRateActual;\r\n    Exp internal HealthyMaxURActual;\r\n    Exp internal HealthyMaxRateActual;\r\n\r\n    constructor(string memory _contractName,uint MinRate,uint HealthyMinUR,uint HealthyMinRate,uint HealthyMaxUR,uint HealthyMaxRate,uint MaxRate, address moneyMarket, address liquidator) LiquidationChecker(moneyMarket, liquidator) public {\r\n        // Remember to enter percentage times 100. ex., if it is 2.50%, enter 250\r\n        owner = msg.sender;\r\n        contractName = _contractName;\r\n        Exp memory  temp1;\r\n        Exp memory temp2;\r\n        Exp memory HunderedMantissa;\r\n        Error err;\r\n\r\n        (err,HunderedMantissa) = getExp(100,1);\r\n\r\n        (err,MinRateActual) = getExp(MinRate,100);\r\n        (err,HealthyMinURActual) = getExp(HealthyMinUR,100);\r\n        (err,HealthyMinRateActual) = getExp(HealthyMinRate,100);\r\n        (err,MaxRateActual) = getExp(MaxRate,100);\r\n        (err,HealthyMaxURActual) = getExp(HealthyMaxUR,100);\r\n        (err,HealthyMaxRateActual) = getExp(HealthyMaxRate,100);\r\n\r\n        SpreadLow = MinRateActual;\r\n        BreakPointLow = HealthyMinURActual;\r\n        BreakPointHigh = HealthyMaxURActual;\r\n\r\n        // ReserveLow = (HealthyMinRate-SpreadLow)/BreakPointLow;\r\n        (err,temp1) = subExp(HealthyMinRateActual,SpreadLow);\r\n        (err,ReserveLow) = divExp(temp1,BreakPointLow);\r\n\r\n        // ReserveMid = (HealthyMaxRate-HealthyMinRate)/(HealthyMaxUR-HealthyMinUR);\r\n        (err,temp1) = subExp(HealthyMaxRateActual,HealthyMinRateActual);\r\n        (err,temp2) = subExp(HealthyMaxURActual,HealthyMinURActual);\r\n        (err,ReserveMid) = divExp(temp1,temp2);\r\n\r\n        // SpreadMid = HealthyMinRate - (ReserveMid * BreakPointLow);\r\n        (err,temp1) = mulExp(ReserveMid,BreakPointLow);\r\n        (err,SpreadMid) = subExp(HealthyMinRateActual,temp1);\r\n\r\n        // ReserveHigh = (MaxRate - HealthyMaxRate) / (100 - HealthyMaxUR);\r\n        (err,temp1) = subExp(MaxRateActual,HealthyMaxRateActual);\r\n        (err,temp2) = subExp(HunderedMantissa,HealthyMaxURActual);\r\n        (err,ReserveHigh) = divExp(temp1,temp2);\r\n\r\n        // SpreadHigh = HealthyMaxRate - (ReserveHigh * BreakPointHigh);\r\n        (err,temp2) = mulExp(ReserveHigh,BreakPointHigh);\r\n        (err,SpreadHigh) = subExpNegative(HealthyMaxRateActual,temp2);\r\n    }\r\n\r\n    function changeRates(string memory _contractName,uint MinRate,uint HealthyMinUR,uint HealthyMinRate,uint HealthyMaxUR,uint HealthyMaxRate,uint MaxRate) public onlyOwner {\r\n        // Remember to enter percentage times 100. ex., if it is 2.50%, enter 250\r\n        contractName = _contractName;\r\n        Exp memory  temp1;\r\n        Exp memory temp2;\r\n        Exp memory HunderedMantissa;\r\n        Error err;\r\n\r\n        (err,HunderedMantissa) = getExp(100,1);\r\n\r\n        (err,MinRateActual) = getExp(MinRate,100);\r\n        (err,HealthyMinURActual) = getExp(HealthyMinUR,100);\r\n        (err,HealthyMinRateActual) = getExp(HealthyMinRate,100);\r\n        (err,MaxRateActual) = getExp(MaxRate,100);\r\n        (err,HealthyMaxURActual) = getExp(HealthyMaxUR,100);\r\n        (err,HealthyMaxRateActual) = getExp(HealthyMaxRate,100);\r\n\r\n        SpreadLow = MinRateActual;\r\n        BreakPointLow = HealthyMinURActual;\r\n        BreakPointHigh = HealthyMaxURActual;\r\n\r\n        // ReserveLow = (HealthyMinRate-SpreadLow)/BreakPointLow;\r\n        (err,temp1) = subExp(HealthyMinRateActual,SpreadLow);\r\n        (err,ReserveLow) = divExp(temp1,BreakPointLow);\r\n\r\n        // ReserveMid = (HealthyMaxRate-HealthyMinRate)/(HealthyMaxUR-HealthyMinUR);\r\n        (err,temp1) = subExp(HealthyMaxRateActual,HealthyMinRateActual);\r\n        (err,temp2) = subExp(HealthyMaxURActual,HealthyMinURActual);\r\n        (err,ReserveMid) = divExp(temp1,temp2);\r\n\r\n        // SpreadMid = HealthyMinRate - (ReserveMid * BreakPointLow);\r\n        (err,temp1) = mulExp(ReserveMid,BreakPointLow);\r\n        (err,SpreadMid) = subExp(HealthyMinRateActual,temp1);\r\n\r\n        // ReserveHigh = (MaxRate - HealthyMaxRate) / (100 - HealthyMaxUR);\r\n        (err,temp1) = subExp(MaxRateActual,HealthyMaxRateActual);\r\n        (err,temp2) = subExp(HunderedMantissa,HealthyMaxURActual);\r\n        (err,ReserveHigh) = divExp(temp1,temp2);\r\n\r\n        // SpreadHigh = HealthyMaxRate - (ReserveHigh * BreakPointHigh);\r\n        (err,temp2) = mulExp(ReserveHigh,BreakPointHigh);\r\n        (err,SpreadHigh) = subExpNegative(HealthyMaxRateActual,temp2);\r\n    }\r\n\r\n    function transferOwnership(address newOwner_) external onlyOwner {\r\n        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\r\n        newOwner = newOwner_;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0x0);\r\n    }\r\n\r\n    function setLiquidator(address _liquidator) external onlyOwner {\r\n        require(_liquidator != address(0), \"setLiquidator: liquidator cannot be a zero address\");\r\n        require(liquidator != _liquidator, \"setLiquidator: The old and new addresses cannot be the same\");\r\n        address oldLiquidator = liquidator;\r\n        liquidator = _liquidator;\r\n        emit LiquidatorUpdate(msg.sender, _liquidator, oldLiquidator);\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates the utilization rate (borrows / (cash + borrows)) as an Exp\r\n     */\r\n    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\r\n        if (borrows == 0) {\r\n            // Utilization rate is zero when there\u0027s no borrows\r\n            return (IRError.NO_ERROR, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err0, uint cashPlusBorrows) = add(cash, borrows);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err1, Exp memory utilizationRate) = getExp(borrows, cashPlusBorrows);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\r\n        }\r\n        (err1,utilizationRate) = mulScalar(utilizationRate,100);\r\n\r\n        return (IRError.NO_ERROR, utilizationRate);\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates the utilization and borrow rates for use by get{Supply,Borrow}Rate functions\r\n     */\r\n    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\r\n        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        /**\r\n         *  Borrow Rate\r\n         *  0 \u003c UR \u003c 20% :      SpreadLow + UR * ReserveLow\r\n         *  20% \u003c= UR \u003c= 80% :  SpreadMid + UR * ReserveMid\r\n         *  80% \u003c UR :          SpreadHigh + UR * ReserveHigh\r\n         */\r\n\r\n        Error err;\r\n\r\n        uint annualBorrowRateScaled;\r\n        Exp memory tempScaled;\r\n        Exp memory tempScaled2;\r\n\r\n        if(utilizationRate.mantissa \u003c BreakPointLow.mantissa) {\r\n            (err, tempScaled) = mulExp(utilizationRate, ReserveLow);\r\n            assert(err == Error.NO_ERROR);\r\n            (err, tempScaled2) = addExp(tempScaled, SpreadLow);\r\n            annualBorrowRateScaled = tempScaled2.mantissa;\r\n            assert(err == Error.NO_ERROR);\r\n        }\r\n        else if (utilizationRate.mantissa \u003e BreakPointHigh.mantissa) {\r\n            (err, tempScaled) = mulExp(utilizationRate, ReserveHigh);\r\n            assert(err == Error.NO_ERROR);\r\n            (err, tempScaled2) = addExpNegative(tempScaled, SpreadHigh);\r\n            annualBorrowRateScaled = tempScaled2.mantissa;\r\n            assert(err == Error.NO_ERROR);\r\n        }\r\n        else if (utilizationRate.mantissa \u003e= BreakPointLow.mantissa \u0026\u0026 utilizationRate.mantissa \u003c= BreakPointHigh.mantissa) {\r\n            (err, tempScaled) = mulExp(utilizationRate, ReserveMid);\r\n            assert(err == Error.NO_ERROR);\r\n            (err, tempScaled2) = addExp(tempScaled, SpreadMid);\r\n            annualBorrowRateScaled = tempScaled2.mantissa;\r\n            assert(err == Error.NO_ERROR);\r\n        }\r\n\r\n        return (IRError.NO_ERROR, utilizationRate, Exp({mantissa: annualBorrowRateScaled / 100}));\r\n    }\r\n\r\n    /**\r\n      * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\r\n      * @dev The return value should be scaled by 1e18, thus a return value of\r\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n      * @param _asset The asset to get the interest rate of\r\n      * @param cash The total cash of the asset in the market\r\n      * @param borrows The total borrows of the asset in the market\r\n      * @return Success or failure and the supply interest rate per block scaled by 10e18\r\n      */\r\n    function getSupplyRate(address _asset, uint cash, uint borrows) public view returns (uint, uint) {\r\n        _asset; // pragma ignore unused argument\r\n        (IRError err0, Exp memory utilizationRate0, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (uint(err0), 0);\r\n        }\r\n\r\n       /**\r\n       *  Supply Rate\r\n       *  = BorrowRate * utilizationRate * (1 - SpreadLow)\r\n       */\r\n       Exp memory temp1;\r\n       Error err1;\r\n       Exp memory oneMinusSpreadBasisPoints;\r\n       (err1,temp1) = getExp(100,1);\r\n       assert(err1 == Error.NO_ERROR);\r\n       (err1,oneMinusSpreadBasisPoints) = subExp(temp1,SpreadLow);\r\n\r\n        // mulScalar only overflows when product is greater than or equal to 2^256.\r\n        // utilization rate\u0027s mantissa is a number between [0e18,1e18]. That means that\r\n        // utilizationRate1 is a value between [0e18,8.5e21]. This is strictly less than 2^256.\r\n        assert(err1 == Error.NO_ERROR);\r\n\r\n        // Next multiply this product times the borrow rate\r\n        (err1, temp1) = mulExp(utilizationRate0, annualBorrowRate);\r\n        // If the product of the mantissas for mulExp are both less than 2^256,\r\n        // then this operation will never fail. TODO: Verify.\r\n        // We know that borrow rate is in the interval [0, 2.25e17] from above.\r\n        // We know that utilizationRate1 is in the interval [0, 9e21] from directly above.\r\n        // As such, the multiplication is in the interval of [0, 2.025e39]. This is strictly\r\n        // less than 2^256 (which is about 10e77).\r\n        assert(err1 == Error.NO_ERROR);\r\n\r\n        (err1, temp1) = mulExp(temp1, oneMinusSpreadBasisPoints);\r\n        assert(err1 == Error.NO_ERROR);\r\n\r\n        // And then divide down by the spread\u0027s denominator (basis points divisor)\r\n        // as well as by blocks per year.\r\n        (Error err4, Exp memory supplyRate) = divScalar(temp1, 10000 * blocksPerYear); // basis points * blocks per year\r\n        // divScalar only fails when divisor is zero. This is clearly not the case.\r\n        assert(err4 == Error.NO_ERROR);\r\n\r\n        return (uint(IRError.NO_ERROR), supplyRate.mantissa);\r\n    }\r\n\r\n    /**\r\n      * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\r\n      * @dev The return value should be scaled by 1e18, thus a return value of\r\n      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n      * @param asset The asset to get the interest rate of\r\n      * @param cash The total cash of the asset in the market\r\n      * @param borrows The total borrows of the asset in the market\r\n      * @return Success or failure and the borrow interest rate per block scaled by 10e18\r\n      */\r\n    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint) {\r\n        asset; // pragma ignore unused argument\r\n\r\n        (IRError err0, , Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (uint(err0), 0);\r\n        }\r\n\r\n        // And then divide down by blocks per year.\r\n        (Error err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\r\n        // divScalar only fails when divisor is zero. This is clearly not the case.\r\n        assert(err1 == Error.NO_ERROR);\r\n\r\n        // Note: mantissa is the rate scaled 1e18, which matches the expected result\r\n        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\r\n    }\r\n}\r\n"},"AlkemiWETH.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract AlkemiWETH {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address =\u003e uint)                       public  balanceOf;\n    mapping (address =\u003e mapping (address =\u003e uint))  public  allowance;\n\n    function() public payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(address user, uint wad) public {\n        require(balanceOf[msg.sender] \u003e= wad);\n        balanceOf[msg.sender] -= wad;\n        user.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] \u003e= wad);\n\n        if (src != msg.sender \u0026\u0026 allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] \u003e= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}"},"CarefulMath.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ErrorReporter.sol\";\n\n/**\n * @title Careful Math\n * @notice Derived from OpenZeppelin\u0027s SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath is ErrorReporter {\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mul(uint a, uint b) internal pure returns (Error, uint) {\n        if (a == 0) {\n            return (Error.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (Error.INTEGER_OVERFLOW, 0);\n        } else {\n            return (Error.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint a, uint b) internal pure returns (Error, uint) {\n        if (b == 0) {\n            return (Error.DIVISION_BY_ZERO, 0);\n        }\n\n        return (Error.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint a, uint b) internal pure returns (Error, uint) {\n        if (b \u003c= a) {\n            return (Error.NO_ERROR, a - b);\n        } else {\n            return (Error.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subInt(uint a, uint b) internal pure returns (Error, int) {\n            return (Error.NO_ERROR, int(a - b));\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function add(uint a, uint b) internal pure returns (Error, uint) {\n        uint c = a + b;\n\n        if (c \u003e= a) {\n            return (Error.NO_ERROR, c);\n        } else {\n            return (Error.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addInt(uint a, int b) internal pure returns (Error, int) {\n        int c = int(a) + b;\n            return (Error.NO_ERROR, c);\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n        (Error err0, uint sum) = add(a, b);\n\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return sub(sum, c);\n    }\n}\n"},"ChainLink.sol":{"content":"pragma solidity 0.4.24;\n\nimport \"./AggregatorV3Interface.sol\";\nimport \u0027./TestTokens.sol\u0027;\n\ncontract ChainLink {\n    \n    mapping(address =\u003e AggregatorV3Interface) internal priceContractMapping;\n    mapping (address =\u003e bool) public assetsWithPriceFeedBasedOnUSD;\n    address public admin;\n    bool public paused = false;\n    address public wethAddress;\n    AggregatorV3Interface public USDETHPriceFeed;\n\n    /**\n     * Sets the initial assets and admin\n     * Add assets and set Weth Address using their own functions\n     */\n    constructor() public {\n        admin = msg.sender;\n    }\n    \n    /**\n     * Modifier to restrict functions only by admins\n     */\n    modifier onlyAdmin() {\n        require(msg.sender == admin,\"Only the Admin can perform this operation\");\n        _;\n    }\n    \n    /**\n     * Event declarations for all the operations of this contract\n     */\n    event assetAdded(address assetAddress, address priceFeedContract);\n    event assetRemoved(address assetAddress);\n    event adminChanged(address oldAdmin, address newAdmin);\n    event wethAddressSet(address wethAddress);\n    event USDETHPriceFeedSet(address USDETHPriceFeed);\n    event contractPausedOrUnpaused(bool currentStatus);\n\n    /**\n     * Allows admin to add a new asset for price tracking\n     */\n    function addAsset(address assetAddress, address priceFeedContract, bool _assetWithPriceFeedBasedOnUSD) public onlyAdmin {\n        if (_assetWithPriceFeedBasedOnUSD) {\n            require(USDETHPriceFeed != address(0),\"USDETHPriceFeed not set\");\n        }\n        priceContractMapping[assetAddress] = AggregatorV3Interface(priceFeedContract);\n        assetsWithPriceFeedBasedOnUSD[assetAddress] = _assetWithPriceFeedBasedOnUSD;\n        emit assetAdded(assetAddress, priceFeedContract);\n    }\n    \n    /**\n     * Allows admin to remove an existing asset from price tracking\n     */\n    function removeAsset(address assetAddress) public onlyAdmin {\n        priceContractMapping[assetAddress] = AggregatorV3Interface(address(0));\n        emit assetRemoved(assetAddress);\n    }\n    \n    /**\n     * Allows admin to change the admin of the contract\n     */\n    function changeAdmin(address newAdmin) public onlyAdmin {\n        emit adminChanged(admin, newAdmin);\n        admin = newAdmin;\n    }\n\n    /**\n     * Allows admin to set the weth address\n     */\n    function setWethAddress(address _wethAddress) public onlyAdmin {\n        wethAddress = _wethAddress;\n        emit wethAddressSet(_wethAddress);\n    }\n\n    /**\n     * Allows admin to set the weth address\n     */\n    function setUSDETHPriceFeedAddress(AggregatorV3Interface _USDETHPriceFeed) public onlyAdmin {\n        USDETHPriceFeed = _USDETHPriceFeed;\n        emit USDETHPriceFeedSet(_USDETHPriceFeed);\n    }\n\n    /**\n     * Allows admin to pause and unpause the contract\n     */\n    function togglePause() public onlyAdmin {\n        if (paused) {\n            paused = false;\n            emit contractPausedOrUnpaused(false);\n        }\n        else {\n            paused = true;\n            emit contractPausedOrUnpaused(true);\n        }\n    }\n\n    /**\n     * Returns the latest price\n     */\n    function getAssetPrice(address asset) public view returns (uint) {\n        // Return 1 * 10^18 for WETH, otherwise return actual price\n        if(!paused \u0026\u0026 asset == wethAddress) {\n            return 1000000000000000000;\n        }\n        // Capture the decimals in the ERC20 token\n        uint8 assetDecimals = TestTokens(asset).decimals();\n        if(!paused \u0026\u0026 priceContractMapping[asset] != address(0)) {\n            (\n                uint80 roundID, \n                int price,\n                uint startedAt,\n                uint timeStamp,\n                uint80 answeredInRound\n            ) = priceContractMapping[asset].latestRoundData();\n            // If the round is not complete yet, timestamp is 0\n            require(timeStamp \u003e 0, \"Round not complete\");\n            // Calculate USD/ETH price for contracts using USD based price feed\n            if(assetsWithPriceFeedBasedOnUSD[asset]) {\n                int priceUSD;\n                (\n                    roundID, \n                    priceUSD,\n                    startedAt,\n                    timeStamp,\n                    answeredInRound\n                ) = USDETHPriceFeed.latestRoundData();\n                // If the round is not complete yet, timestamp is 0\n                require(timeStamp \u003e 0, \"Round not complete\");\n                uint returnedPrice = uint(price) * uint(priceUSD) / (10 ** 8);\n                return returnedPrice;\n            } else {\n                if(price \u003e0) {\n                // Magnify the result based on decimals\n                return (uint(price) * (10 ** (18 - uint(assetDecimals))));\n            }\n            else {\n                return 0;\n            }\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function fallback() public payable {\n        require(msg.sender.send(msg.value),\"Fallback function initiated but refund failed\");\n    }\n}"},"EIP20Interface.sol":{"content":"// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.4.24;\n\n\ncontract EIP20Interface {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    // total amount of tokens\n    uint256 public totalSupply;\n    /**\n     * @param _owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    /**\n     * @notice send `_value` token to `_to` from `msg.sender`\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /**\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /**\n     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @param _value The amount of tokens to be approved for transfer\n     * @return Whether the approval was successful or not\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /**\n     * @param _owner The address of the account owning tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @return Amount of remaining tokens allowed to spent\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"EIP20NonStandardInterface.sol":{"content":"// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.4.24;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n * See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ncontract EIP20NonStandardInterface {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    // total amount of tokens\n    uint256 public totalSupply;\n\n    /**\n     * @param _owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    /**\n     * !!!!!!!!!!!!!!\n     * !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n     * !!!!!!!!!!!!!!\n     *\n     * @notice send `_value` token to `_to` from `msg.sender`\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transfer(address _to, uint256 _value) public;\n\n    /**\n     *\n     * !!!!!!!!!!!!!!\n     * !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n     * !!!!!!!!!!!!!!\n     *\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value The amount of token to be transferred\n     * @return Whether the transfer was successful or not\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public;\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /**\n     * @param _owner The address of the account owning tokens\n     * @param _spender The address of the account able to transfer the tokens\n     * @return Amount of remaining tokens allowed to spent\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"},"ErrorReporter.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract ErrorReporter {\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     */\n    event Failure(uint error, uint info, uint detail);\n\n    enum Error {\n        NO_ERROR,\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n        UNAUTHORIZED,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW,\n        DIVISION_BY_ZERO,\n        BAD_INPUT,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_TRANSFER_FAILED,\n        MARKET_NOT_SUPPORTED,\n        SUPPLY_RATE_CALCULATION_FAILED,\n        BORROW_RATE_CALCULATION_FAILED,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_OUT_FAILED,\n        INSUFFICIENT_LIQUIDITY,\n        INSUFFICIENT_BALANCE,\n        INVALID_COLLATERAL_RATIO,\n        MISSING_ASSET_PRICE,\n        EQUITY_INSUFFICIENT_BALANCE,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        ASSET_NOT_PRICED,\n        INVALID_LIQUIDATION_DISCOUNT,\n        INVALID_COMBINED_RISK_PARAMETERS,\n        ZERO_ORACLE_ADDRESS,\n        CONTRACT_PAUSED,\n        KYC_ADMIN_CHECK_FAILED,\n        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\n        LIQUIDATOR_CHECK_FAILED,\n        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\n        WETH_ADDRESS_NOT_SET_ERROR,\n        ETHER_AMOUNT_MISMATCH_ERROR\n    }\n\n    /**\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n        BORROW_CONTRACT_PAUSED,\n        BORROW_MARKET_NOT_SUPPORTED,\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n        BORROW_TRANSFER_OUT_FAILED,\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n        LIQUIDATE_CONTRACT_PAUSED,\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\n        LIQUIDATE_TRANSFER_IN_FAILED,\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_CONTRACT_PAUSED,\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_ASSET_PRICE_CHECK_ORACLE,\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_ORACLE_OWNER_CHECK,\n        SET_ORIGINATION_FEE_OWNER_CHECK,\n        SET_PAUSED_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RISK_PARAMETERS_OWNER_CHECK,\n        SET_RISK_PARAMETERS_VALIDATION,\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        SUPPLY_CONTRACT_PAUSED,\n        SUPPLY_MARKET_NOT_SUPPORTED,\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        SUPPLY_TRANSFER_IN_FAILED,\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n        SUPPORT_MARKET_FETCH_PRICE_FAILED,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SUPPORT_MARKET_PRICE_CHECK,\n        SUSPEND_MARKET_OWNER_CHECK,\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n        WITHDRAW_CONTRACT_PAUSED,\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        WITHDRAW_TRANSFER_OUT_FAILED,\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE,\n        KYC_ADMIN_CHECK_FAILED,\n        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\n        LIQUIDATOR_CHECK_FAILED,\n        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\n        WETH_ADDRESS_NOT_SET_ERROR,\n        SEND_ETHER_ADMIN_CHECK_FAILED,\n        ETHER_AMOUNT_MISMATCH_ERROR\n    }\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n\n        return uint(Error.OPAQUE_ERROR);\n    }\n}\n"},"Exponential.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ErrorReporter.sol\";\nimport \"./CarefulMath.sol\";\n\ncontract Exponential is ErrorReporter, CarefulMath {\n    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\n    uint constant expScale = 10**18;\n\n    // See TODO on expScale\n    uint constant halfExpScale = expScale/2;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct ExpNegative {\n        int mantissa;\n    }\n\n    uint constant mantissaOne = 10**18;\n    uint constant mantissaOneTenth = 10**17;\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) \u003e MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n        (Error err0, uint scaledNumerator) = mul(num, expScale);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (Error err1, uint rational) = div(scaledNumerator, denom);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n        (Error error, uint result) = add(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExpNegative(Exp memory a, ExpNegative memory b) pure internal returns (Error, Exp memory) {\n        (Error error, int result) = addInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: uint(result)}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExpNegative(Exp memory a, Exp memory b) pure internal returns (Error, ExpNegative memory) {\n        (Error error, int result) = subInt(a.mantissa, b.mantissa);\n\n        return (error, ExpNegative({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\n        /*\n            We are doing this as:\n            getExp(mul(expScale, scalar), divisor.mantissa)\n\n            How it works:\n            Exp = a / b;\n            Scalar = s;\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (Error err0, uint numerator) = mul(expScale, scalar);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n\n        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == Error.NO_ERROR);\n\n        return (Error.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we\u0027re performing a division that cannot fail\n        return exp.mantissa / 10**18;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa \u003c right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n    }\n\n    /**\n     * @dev Checks if left Exp \u003c= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa \u003c= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if first Exp is greater than second Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa \u003e right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n}\n\n"},"InterestRateModel.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title InterestRateModel Interface\n * @notice Any interest rate model should derive from this contract.\n * @dev These functions are specifically not marked `pure` as implementations of this\n *      contract may read from storage variables.\n */\ncontract InterestRateModel {\n    /**\n     * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\n     * @dev The return value should be scaled by 1e18, thus a return value of\n     *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n     * @param asset The asset to get the interest rate of\n     * @param cash The total cash of the asset in the market\n     * @param borrows The total borrows of the asset in the market\n     * @return Success or failure and the supply interest rate per block scaled by 10e18\n     */\n    function getSupplyRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\n\n    /**\n     * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\n     * @dev The return value should be scaled by 1e18, thus a return value of\n     *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n     * @param asset The asset to get the interest rate of\n     * @param cash The total cash of the asset in the market\n     * @param borrows The total borrows of the asset in the market\n     * @return Success or failure and the borrow interest rate per block scaled by 10e18\n     */\n    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint);\n}\n"},"LiquidationChecker.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./EIP20Interface.sol\";\nimport \"./PriceOracleProxy.sol\";\nimport \"./MoneyMarket.sol\";\n\ncontract LiquidationChecker {\n    MoneyMarket public moneyMarket;\n    address public liquidator;\n    bool public allowLiquidation;\n\n    constructor(address moneyMarket_, address liquidator_) public {\n        moneyMarket = MoneyMarket(moneyMarket_);\n        liquidator = liquidator_;\n        allowLiquidation = false;\n    }\n\n    function isAllowed(address asset, uint newCash) internal view returns(bool) {\n        return allowLiquidation || !isLiquidate(asset, newCash);\n    }\n\n    function isLiquidate(address asset, uint newCash) internal view returns(bool) {\n        return cashIsUp(asset, newCash) \u0026\u0026 oracleTouched();\n    }\n\n    function cashIsUp(address asset, uint newCash) internal view returns(bool) {\n        uint oldCash = EIP20Interface(asset).balanceOf(moneyMarket);\n\n        return newCash \u003e= oldCash;\n    }\n\n    function oracleTouched() internal view returns(bool) {\n        PriceOracleProxy oracle = PriceOracleProxy(moneyMarket.oracle());\n\n        bool sameOrigin = oracle.mostRecentCaller() == tx.origin;\n        bool sameBlock = oracle.mostRecentBlock() == block.number;\n\n        return sameOrigin \u0026\u0026 sameBlock;\n    }\n\n    function setAllowLiquidation(bool allowLiquidation_) public {\n        require(msg.sender == liquidator, \"LIQUIDATION_CHECKER_INVALID_LIQUIDATOR\");\n\n        allowLiquidation = allowLiquidation_;\n    }\n}\n"},"Liquidator.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./MoneyMarket.sol\";\nimport \"./LiquidationChecker.sol\";\n\ncontract Liquidator is ErrorReporter, SafeToken {\n    MoneyMarket public moneyMarket;\n\n    constructor(address moneyMarket_) public {\n        moneyMarket = MoneyMarket(moneyMarket_);\n    }\n\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) public returns (uint) {\n        require(targetAccount != address(this), \"FAILED_LIQUIDATE_LIQUIDATOR\");\n        require(targetAccount != msg.sender, \"FAILED_LIQUIDATE_SELF\");\n        require(msg.sender != address(this), \"FAILED_LIQUIDATE_RECURSIVE\");\n        require(assetBorrow != assetCollateral, \"FAILED_LIQUIDATE_IN_KIND\");\n\n        InterestRateModel interestRateModel;\n        (,,interestRateModel,,,,,,) = moneyMarket.markets(assetBorrow);\n\n        require(interestRateModel != address(0), \"FAILED_LIQUIDATE_NO_INTEREST_RATE_MODEL\");\n        require(checkTransferIn(assetBorrow, msg.sender, requestedAmountClose) == Error.NO_ERROR, \"FAILED_LIQUIDATE_TRANSFER_IN_INVALID\");\n\n        require(doTransferIn(assetBorrow, msg.sender, requestedAmountClose) == Error.NO_ERROR, \"FAILED_LIQUIDATE_TRANSFER_IN_FAILED\");\n\n        tokenAllowAll(assetBorrow, moneyMarket);\n\n        LiquidationChecker(interestRateModel).setAllowLiquidation(true);\n\n        uint result = moneyMarket.liquidateBorrow(targetAccount, assetBorrow, assetCollateral, requestedAmountClose);\n\n        require(moneyMarket.withdraw(assetCollateral, uint(-1)) == uint(Error.NO_ERROR), \"FAILED_LIQUIDATE_WITHDRAW_FAILED\");\n\n        LiquidationChecker(interestRateModel).setAllowLiquidation(false);\n\n        // Ensure there\u0027s no remaining balances here\n        require(moneyMarket.getSupplyBalance(address(this), assetCollateral) == 0, \"FAILED_LIQUIDATE_REMAINING_SUPPLY_COLLATERAL\"); // just to be sure\n        require(moneyMarket.getSupplyBalance(address(this), assetBorrow) == 0, \"FAILED_LIQUIDATE_REMAINING_SUPPLY_BORROW\"); // just to be sure\n        require(moneyMarket.getBorrowBalance(address(this), assetCollateral) == 0, \"FAILED_LIQUIDATE_REMAINING_BORROW_COLLATERAL\"); // just to be sure\n        require(moneyMarket.getBorrowBalance(address(this), assetBorrow) == 0, \"FAILED_LIQUIDATE_REMAINING_BORROW_BORROW\"); // just to be sure\n\n        // Transfer out everything remaining\n        tokenTransferAll(assetCollateral, msg.sender);\n        tokenTransferAll(assetBorrow, msg.sender);\n\n        return uint(result);\n    }\n\n    function tokenAllowAll(address asset, address allowee) internal {\n        EIP20Interface token = EIP20Interface(asset);\n\n        if (token.allowance(address(this), allowee) != uint(-1))\n            // require(token.approve(allowee, uint(-1)), \"FAILED_LIQUIDATE_ASSET_ALLOWANCE_FAILED\");\n            require(doApprove(asset, allowee, uint(-1)) == Error.NO_ERROR, \"FAILED_LIQUIDATE_ASSET_ALLOWANCE_FAILED\");\n    }\n\n    function tokenTransferAll(address asset, address recipient) internal {\n        uint balance = getBalanceOf(asset, address(this));\n\n        if (balance \u003e 0){\n            require(doTransferOut(asset, recipient, balance) == Error.NO_ERROR, \"FAILED_LIQUIDATE_TRANSFER_OUT_FAILED\");\n        }\n    }\n}\n"},"Migrations.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"},"MoneyMarket.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./ChainLink.sol\";\nimport \"./AlkemiWETH.sol\";\n\ncontract MoneyMarket is Exponential, SafeToken {\n\n    uint internal initialInterestIndex;\n    uint internal defaultOriginationFee; \n    uint internal defaultCollateralRatio;\n    uint internal defaultLiquidationDiscount;\n\n    uint internal minimumCollateralRatioMantissa;\n    uint internal maximumLiquidationDiscountMantissa;\n    bool public initializationDone; // To make sure initializer is called only once\n\n    /**\n     * @notice `MoneyMarket` is the core MoneyMarket contract\n     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n     * @notice Hence this contract has an \u0027initializer\u0027 in place of a \u0027constructor\u0027\n     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n     */\n    function initializer() public {\n        if(initializationDone == false) {\n            initializationDone = true;\n            admin = msg.sender;\n            initialInterestIndex = 10 ** 18;\n            defaultOriginationFee = (10 ** 15); // default is 0.1%\n            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n            originationFee = Exp({mantissa: defaultOriginationFee});\n            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n            // oracle must be configured via _setOracle\n        }\n    }\n\n    /**\n     * @notice Do not pay directly into MoneyMarket, please use `supply`.\n     */\n    function() payable public {\n        revert();\n    }\n\n    /**\n     * @dev pending Administrator for this contract.\n     */\n    address public pendingAdmin;\n\n    /**\n     * @dev Administrator for this contract. Initially set in constructor, but can\n     *      be changed by the admin itself.\n     */\n    address public admin;\n\n    /**\n     * @dev Managers for this contract with limited permissions. Can\n     *      be changed by the admin.\n     */\n    mapping (address =\u003e bool) public managers;\n\n    /**\n     * @dev Account allowed to set oracle prices for this contract. Initially set\n     *      in constructor, but can be changed by the admin.\n     */\n    address public oracle;\n\n    /**\n     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n     */\n    ChainLink priceOracle;\n\n    /**\n     * @dev Container for customer balance information written to storage.\n     *\n     *      struct Balance {\n     *        principal = customer total balance with accrued interest after applying the customer\u0027s most recent balance-changing action\n     *        interestIndex = the total interestIndex as calculated after applying the customer\u0027s most recent balance-changing action\n     *      }\n     */\n    struct Balance {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for supplies\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public supplyBalances;\n\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public borrowBalances;\n\n\n    /**\n     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n     *\n     *      struct Market {\n     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n     *         blockNumber = when the other values in this struct were calculated\n     *         totalSupply = total amount of this asset supplied (in asset wei)\n     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n     *     }\n     */\n    struct Market {\n        bool isSupported;\n        uint blockNumber;\n        InterestRateModel interestRateModel;\n\n        uint totalSupply;\n        uint supplyRateMantissa;\n        uint supplyIndex;\n\n        uint totalBorrows;\n        uint borrowRateMantissa;\n        uint borrowIndex;\n    }\n\n    /**\n     * @dev wethAddress to hold the WETH token contract address\n     * set using setWethAddress function\n     */\n    address public wethAddress;\n\n    /**\n     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n     */\n    AlkemiWETH public WETHContract;\n\n    /**\n     * @dev map: assetAddress -\u003e Market\n     */\n    mapping(address =\u003e Market) public markets;\n\n    /**\n     * @dev list: collateralMarkets\n     */\n    address[] public collateralMarkets;\n\n    /**\n     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n     *      is initially set in the constructor, but can be changed by the admin.\n     */\n    Exp public collateralRatio;\n\n    /**\n     * @dev originationFee for new borrows.\n     *\n     */\n    Exp public originationFee;\n\n    /**\n     * @dev liquidationDiscount for collateral when liquidating borrows\n     *\n     */\n    Exp public liquidationDiscount;\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    /**\n     * @dev Mapping to identify the list of KYC Admins\n     */\n    mapping(address=\u003ebool) private KYCAdmins;\n    /**\n     * @dev Mapping to identify the list of customers with verified KYC\n     */\n    mapping(address=\u003ebool) private customersWithKYC;\n\n    /**\n     * @dev Mapping to identify the list of customers with Liquidator roles\n     */\n    mapping(address=\u003ebool) private liquidators;\n\n    /**\n     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n    struct SupplyLocalVars {\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n    }\n\n    /**\n     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n\n    struct WithdrawLocalVars {\n        uint withdrawAmount;\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfWithdrawal;\n        uint withdrawCapacity;\n    }\n\n    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n    struct AccountValueLocalVars {\n        address assetAddress;\n        uint collateralMarketsLength;\n\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        Exp supplyTotalValue;\n        Exp sumSupplies;\n\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        Exp borrowTotalValue;\n        Exp sumBorrows;\n    }\n\n    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n    struct PayBorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint repayAmount;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n    }\n\n    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n    struct BorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint borrowAmountWithFee;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfBorrowAmountWithFee;\n    }\n\n    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n    struct LiquidateLocalVars {\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n        address targetAccount;\n        address assetBorrow;\n        address liquidator;\n        address assetCollateral;\n\n        // borrow index and supply index are global to the asset, not specific to the user\n        uint newBorrowIndex_UnderwaterAsset;\n        uint newSupplyIndex_UnderwaterAsset;\n        uint newBorrowIndex_CollateralAsset;\n        uint newSupplyIndex_CollateralAsset;\n\n        // the target borrow\u0027s full balance with accumulated interest\n        uint currentBorrowBalance_TargetUnderwaterAsset;\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\n\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\n\n        uint startingBorrowBalance_TargetUnderwaterAsset;\n        uint startingSupplyBalance_TargetCollateralAsset;\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\n\n        uint currentSupplyBalance_TargetCollateralAsset;\n        uint updatedSupplyBalance_TargetCollateralAsset;\n\n        // If liquidator already has a balance of collateralAsset, we will accumulate\n        // interest on it before transferring seized collateral from the borrower.\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\n        // This will be the liquidator\u0027s accumulated balance of collateral asset before the liquidation (if any)\n        // plus the amount seized from the borrower.\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n\n        uint newTotalSupply_ProtocolCollateralAsset;\n        uint currentCash_ProtocolUnderwaterAsset;\n        uint updatedCash_ProtocolUnderwaterAsset;\n\n        // cash does not change for collateral asset\n\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n\n        // Why no variables for the interest rates for the collateral asset?\n        // We don\u0027t need to calculate new rates for the collateral asset since neither cash nor borrows change\n\n        uint discountedRepayToEvenAmount;\n\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n        uint discountedBorrowDenominatedCollateral;\n\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        uint closeBorrowAmount_TargetUnderwaterAsset;\n        uint seizeSupplyAmount_TargetCollateralAsset;\n\n        Exp collateralPrice;\n        Exp underwaterAssetPrice;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e originationFeeBalance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e uint)) public originationFeeBalance;\n\n    /**\n     * @dev Event emitted on successful addition of Weth Address\n     */\n    event WETHAddressSet(address wethAddress);\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event LiquidatorAdded(address Liquidator);\n    event LiquidatorRemoved(address Liquidator);\n\n    /**\n     * @dev emitted when a supply is received\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a origination fee supply is received as admin\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n    /**\n     * @dev emitted when a supply is withdrawn\n     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a new borrow is taken\n     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n     */\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is repaid\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is liquidated\n     *      targetAccount = user whose borrow was liquidated\n     *      assetBorrow = asset borrowed\n     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountRepaid = amount of borrow repaid\n     *      liquidator = account requesting the liquidation\n     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountSeized = amount of collateral seized by liquidator\n     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n     */\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    /**\n     * @dev emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev newOracle - address of new oracle\n     */\n    event NewOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev emitted when new market is supported by admin\n     */\n    event SupportedMarket(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when risk parameters are changed by admin\n     */\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n\n    /**\n     * @dev emitted when origination fee is changed by admin\n     */\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n\n    /**\n     * @dev emitted when market has new interest rate model set\n     */\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when admin withdraws equity\n     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n     */\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n\n    /**\n     * @dev emitted when a supported market is suspended by admin\n     */\n    event SuspendedMarket(address asset);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev KYC Integration\n     */\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event KYCAdminAdded(address KYCAdmin);\n    event KYCAdminRemoved(address KYCAdmin);\n    event KYCCustomerAdded(address KYCCustomer);\n    event KYCCustomerRemoved(address KYCCustomer);\n\n    /**\n     * @dev Modifier to check if the caller of the function is a manager or owner\n     */\n    modifier onlyAdminOrManager {\n        // Check caller = KYCadmin\n        require(msg.sender == admin || managers[msg.sender],\"Only owner or manager can perform operation\");\n        _;\n    }\n\n    /**\n     * @dev Function to emit fail event to frontend\n     */\n    function emitError(Error error, FailureInfo failure) private returns(uint) {\n        return fail(error, failure);\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is a KYC Admin\n     */\n    modifier isKYCAdmin {\n        // Check caller = KYCadmin\n        if (!KYCAdmins[msg.sender]) {\n            emitError(Error.KYC_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_CHECK_FAILED);\n        } else {\n            require(KYCAdmins[msg.sender],\"Operation can only be performed by a KYC Admin\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is KYC verified\n     */\n    modifier isKYCVerifiedCustomer {\n        // Check caller = KYCVerifiedCustomer\n        if (!customersWithKYC[msg.sender]) {\n            revertEtherToUser(msg.sender,msg.value);\n            emitError(Error.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED, FailureInfo.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED);\n        } else {\n            require(customersWithKYC[msg.sender],\"Customer is not KYC Verified\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add KYC Admins\n     */\n    function addKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = true;\n        emit KYCAdminAdded(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove KYC Admins\n     */\n    function removeKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = false;\n        emit KYCAdminRemoved(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to add KYC Customers\n     */\n    function addCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = true;\n        emit KYCCustomerAdded(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to remove KYC Customers\n     */\n    function removeCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = false;\n        emit KYCCustomerRemoved(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch KYC verification status of a customer\n     */\n    function verifyKYC(address customer) public view returns(bool) {\n        return customersWithKYC[customer];\n    }\n\n    /**\n     * @dev Function to fetch KYC Admin status of an admin\n     */\n    function checkKYCAdmin(address _KYCAdmin) public view returns(bool) {\n        return KYCAdmins[_KYCAdmin];\n    }\n\n    /**\n     * @dev Liquidator Integration\n     */\n\n    /**\n     * @dev Modifier to check if the caller of the function is a Liquidator\n     */\n    modifier isLiquidator {\n        // Check caller = Liquidator\n        if (!liquidators[msg.sender]) {\n            emitError(Error.LIQUIDATOR_CHECK_FAILED, FailureInfo.LIQUIDATOR_CHECK_FAILED);\n        } else {\n            require(liquidators[msg.sender],\"Customer is not a Liquidator\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add Liquidators\n     */\n    function addLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = true;\n        emit LiquidatorAdded(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove Liquidators\n     */\n    function removeLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = false;\n        emit LiquidatorRemoved(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch Liquidator status of a customer\n     */\n    function verifyLiquidator(address liquidator) public view returns(bool) {\n        return liquidators[liquidator];\n    }\n\n    /**\n     * @dev Simple function to calculate min between two numbers.\n     */\n    function min(uint a, uint b) pure internal returns (uint) {\n        if (a \u003c b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *      This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n     *      Note: this will not add the asset if it already exists.\n     */\n    function addCollateralMarket(address asset) internal {\n        for (uint i = 0; i \u003c collateralMarkets.length; i++) {\n            if (collateralMarkets[i] == asset) {\n                return;\n            }\n        }\n\n        collateralMarkets.push(asset);\n    }\n\n    /**\n     * @notice return the number of elements in `collateralMarkets`\n     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n     * @return the length of `collateralMarkets`\n     */\n    function getCollateralMarketsLength() public view returns (uint) {\n        return collateralMarkets.length;\n    }\n\n    /**\n     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n     */\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n\n        // Get the block delta\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        // Scale the interest rate times number of blocks\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n        if (err2 != Error.NO_ERROR) {\n            return (err2, 0);\n        }\n\n        // Then scale that accumulated interest by the old interest index to get the new interest index\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n        if (err3 != Error.NO_ERROR) {\n            return (err3, 0);\n        }\n\n        // Finally, truncate the interest index. This works only if interest index starts large enough\n        // that is can be accurately represented with a whole number.\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n    }\n\n    /**\n     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n     *      This is defined as: `The user\u0027s last balance checkpoint is multiplied by the currentSupplyIndex\n     *      value and divided by the user\u0027s checkpoint index value`\n     *\n     *      TODO: Is there a way to handle this that is less likely to overflow?\n     */\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n        if (startingBalance == 0) {\n            // We are accumulating interest on any previous balance; if there\u0027s no previous balance, then there is\n            // nothing to accumulate.\n            return (Error.NO_ERROR, 0);\n        }\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return div(balanceTimesIndex, interestIndexStart);\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset.\n     */\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n     */\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory scaledPrice;\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        // Now, multiply the assetValue by the collateral ratio\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        // Get the price for the given asset amount\n        return mulScalar(scaledPrice, assetAmount);\n    }\n\n    /**\n     * @dev Calculates the origination fee added to a given borrowAmount\n     *      This is simply `(1 + originationFee) * borrowAmount`\n     *\n     *      TODO: Track at what magnitude this fee rounds down to zero?\n     */\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n        // When origination fee is zero, the amount with fee is simply equal to the amount\n        if (isZeroExp(originationFee)) {\n            return (Error.NO_ERROR, borrowAmount);\n        }\n\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n    }\n\n    /**\n     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n     * @param asset asset whose price should be fetched\n     */\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n        if (oracle == address(0)) {\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n        }\n\n        uint priceMantissa = priceOracle.getAssetPrice(asset);\n\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n    }\n\n    /**\n     * @notice Reads scaled price of specified asset from the price oracle\n     * @dev Reads scaled price of specified asset from the price oracle.\n     *      The plural name is to match a previous storage mapping that this function replaced.\n     * @param asset Asset whose price should be retrieved\n     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return 0;\n        }\n        return result.mantissa;\n    }\n\n    /**\n     * @dev Gets the amount of the specified asset given the specified Eth value\n     *      ethValue / oraclePrice = assetAmountWei\n     *      If there\u0027s no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n     */\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory assetAmount;\n\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, assetAmount) = divExp(ethValue, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(assetAmount));\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller = pendingAdmin\n        // msg.sender can\u0027t be zero\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAdmin = admin;\n        // Store admin = pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = 0;\n\n        emit NewAdmin(oldAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new oracle, who can set asset prices\n     * @dev Admin function to change oracle\n     * @param newOracle New oracle address\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOracle(address newOracle) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n        }\n\n        // Verify contract at newOracle address supports assetPrices call.\n        // This will revert if it doesn\u0027t.\n        // ChainLink priceOracleTemp = ChainLink(newOracle);\n        // priceOracleTemp.getAssetPrice(address(0));\n\n        address oldOracle = oracle;\n\n        // Store oracle = newOracle\n        oracle = newOracle;\n        // Initialize the Chainlink contract in priceOracle\n        priceOracle = ChainLink(newOracle);\n\n        emit NewOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice returns the liquidity for given account.\n     *         a positive result indicates ability to borrow, whereas\n     *         a negative result indicates a shortfall which may be liquidated\n     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n     *      note: this includes interest trued up on all balances\n     * @param account the account to examine\n     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n     */\n    function getAccountLiquidity(address account) public view returns (int) {\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n        require(err == Error.NO_ERROR);\n\n        if (isZeroExp(accountLiquidity)) {\n            return -1 * int(truncate(accountShortfall));\n        } else {\n            return int(truncate(accountLiquidity));\n        }\n    }\n\n    /**\n     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose supply balance belonging to `account` should be checked\n     * @return uint supply balance on success, throws on failed assertion otherwise\n     */\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[account][asset];\n\n        // Calculate the newSupplyIndex, needed to calculate user\u0027s supplyCurrent\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n        require(err == Error.NO_ERROR);\n\n        return userSupplyCurrent;\n    }\n\n    /**\n     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n     * @return uint borrow balance on success, throws on failed assertion otherwise\n     */\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[account][asset];\n\n        // Calculate the newBorrowIndex, needed to calculate user\u0027s borrowCurrent\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n        require(err == Error.NO_ERROR);\n\n        return userBorrowCurrent;\n    }\n\n\n    /**\n     * @notice Supports a given market (asset) for use\n     * @dev Admin function to add support for a market\n     * @param asset Asset to support; MUST already have a non-zero price set\n     * @param interestRateModel InterestRateModel to use for the asset\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        // Append asset to collateralAssets if not set\n        addCollateralMarket(asset);\n\n        // Set market isSupported to true\n        markets[asset].isSupported = true;\n\n        // Default supply and borrow index to 1e18\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n\n        emit SupportedMarket(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Suspends a given *supported* market (asset) from use.\n     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n     * @dev Admin function to suspend a market\n     * @param asset Asset to suspend\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _suspendMarket(address asset) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n        }\n\n        // If the market is not configured at all, we don\u0027t want to add any configuration for it.\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n        // has already been marked as unsupported. We can just return without doing anything.\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n        if (!markets[asset].isSupported) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // If we get here, we know market is configured and is supported, so set isSupported to false\n        markets[asset].isSupported = false;\n\n        emit SuspendedMarket(asset);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n     * @dev Owner function to set the risk parameters\n     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be \u003c= 0.1 and must be less than (descaled collateral ratio minus 1)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n        }\n\n        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n\n        Error err;\n        Exp memory newLiquidationDiscountPlusOne;\n\n        // Make sure new collateral ratio value is not below minimum value\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n        // C \u003c L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Save current values so we can emit them in log.\n        Exp memory oldCollateralRatio = collateralRatio;\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\n\n        // Store new values\n        collateralRatio = newCollateralRatio;\n        liquidationDiscount = newLiquidationDiscount;\n\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the origination fee (which is a multiplier on new borrows)\n     * @dev Owner function to set the origination fee\n     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n        }\n\n        // Save current value so we can emit it in log.\n        Exp memory oldOriginationFee = originationFee;\n\n        originationFee = Exp({mantissa: originationFeeMantissa});\n\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the interest rate model for a given market\n     * @dev Admin function to set interest rate model\n     * @param asset Asset to support\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        emit SetMarketInterestRateModel(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` \u003c= equity. Equity= cash - (supply + borrows)\n     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount \u003c= cash - (supply + borrows)\n     * @param asset asset whose equity should be withdrawn\n     * @param amount amount of equity to withdraw; must not exceed equity available\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n        }\n\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n        uint cash = getCash(asset);\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n        if (err0 != Error.NO_ERROR) {\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n        }\n\n        if (amount \u003e equity) {\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset out of the protocol to the admin\n            Error err2 = doTransferOut(asset, admin, amount);\n            if (err2 != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n        emit EquityWithdrawn(asset, equity, amount, admin);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Set WETH token contract address\n     * @param wethContractAddress Enter the WETH token address\n     */\n    function setWethAddress(address wethContractAddress) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n        }\n        wethAddress = wethContractAddress;\n        WETHContract = AlkemiWETH(wethAddress);\n        emit WETHAddressSet(wethContractAddress);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n     * @return errors if any\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n        user; // To silence the warning of unused local variable\n        if(wethAddress != address(0)){\n            WETHContract.deposit.value(etherAmount)();\n            return uint(Error.NO_ERROR);\n        }\n        else {\n            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n        }\n    }\n\n    /**\n     * @dev Revert Ether paid by user back to user\u0027s account in case transaction fails due to some other reason\n     * @param etherAmount Amount of ether to be sent back to user\n     * @param user User account address\n     */\n    function revertEtherToUser(address user, uint etherAmount) internal {\n        if(etherAmount \u003e 0){\n            user.transfer(etherAmount);\n        }\n    }\n\n    /**\n     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n     * @dev add amount of supported asset to msg.sender\u0027s account\n     * @param asset The market asset to supply\n     * @param amount The amount to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function supply(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage balance = supplyBalances[msg.sender][asset];\n\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n        }\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // Fail gracefully if asset is not approved or has insufficient balance\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n        balance.principal = localResults.userSupplyUpdated;\n        balance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice withdraw `amount` of `ether` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `ether` from msg.sender\u0027s account to msg.sender\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n            WETHContract.withdraw(user,etherAmount);\n            return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice send Ether from contract to a user\n     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n     */\n    function sendEtherToUser(address user, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n        }\n        user.transfer(amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraw `amount` of `asset` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `asset` from msg.sender\u0027s account to msg.sender\n     * @param asset The market asset to withdraw\n     * @param requestedAmount The amount to withdraw (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function withdraw(address asset, uint requestedAmount) public isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // We calculate the user\u0027s accountLiquidity and accountShortfall.\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount =\u003e the lesser of withdrawCapacity and supplyCurrent\n        if (requestedAmount == uint(-1)) {\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n            }\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n        } else {\n            localResults.withdrawAmount = requestedAmount;\n        }\n\n        // From here on we should NOT use requestedAmount.\n\n        // Fail gracefully if protocol has insufficient cash\n        // If protocol has insufficient cash, the sub operation will underflow.\n        localResults.currentCash = getCash(asset);\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        // We check that the amount is less than or equal to supplyCurrent\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // We want to know the user\u0027s withdrawCapacity, denominated in the asset\n        // Customer\u0027s withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply.\n        // Note that, even though the customer is withdrawing, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // failure\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n        supplyBalance.principal = localResults.userSupplyUpdated;\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n        \n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Gets the user\u0027s account liquidity and account shortfall balances. This includes\n     *      any accumulated interest thus far but does NOT actually update anything in\n     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n     */\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n        Error err;\n        uint sumSupplyValuesMantissa;\n        uint sumBorrowValuesMantissa;\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        Exp memory result;\n\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // if sumSupplies \u003c sumBorrows, then the user is under collateralized and has account shortfall.\n        // else the user meets the collateral ratio and has account liquidity.\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n            // accountShortfall = borrows - supplies\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n        } else {\n            // accountLiquidity = supplies - borrows\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n        }\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n     * TODO: To help save gas we could think about using the current Market.interestIndex\n     *       accumulate interest rather than calculating it\n     */\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n\n        /** By definition, all collateralMarkets are those that contribute to the user\u0027s\n         * liquidity and shortfall so we need only loop through those markets.\n         * To handle avoiding intermediate negative results, we will sum all the user\u0027s\n         * supply balances and borrow balances (with collateral ratio) separately and then\n         * subtract the sums at the end.\n         */\n\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n        localResults.sumSupplies = Exp({mantissa: 0});\n        localResults.sumBorrows = Exp({mantissa: 0});\n        Error err; // Re-used for all intermediate errors\n        localResults.collateralMarketsLength = collateralMarkets.length;\n\n        for (uint i = 0; i \u003c localResults.collateralMarketsLength; i++) {\n            localResults.assetAddress = collateralMarkets[i];\n            Market storage currentMarket = markets[localResults.assetAddress];\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n\n            if (supplyBalance.principal \u003e 0) {\n                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // We have the user\u0027s supply balance with interest so let\u0027s multiply by the asset price to get the total value\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of supplies\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n\n            if (borrowBalance.principal \u003e 0) {\n                // We perform a similar actions to get the user\u0027s borrow balance\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of borrows\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n        }\n\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n     *          sum ETH value of supplies scaled by 10e18,\n     *          sum ETH value of borrows scaled by 10e18)\n     */\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n\n            return (uint(err), 0, 0);\n        }\n\n        return (0, supplyValue, borrowValue);\n    }\n\n    /**\n     * @notice Users repay borrowed assets from their own address to the protocol.\n     * @param asset The market asset to repay\n     * @param amount The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n        }\n        PayBorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n        Error err;\n        uint rateCalculationResultCode;\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to repay (“max”), repayAmount =\u003e\n        // the lesser of the senders ERC-20 balance and borrowCurrent\n        if (amount == uint(-1)) {\n            localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n        } else {\n            localResults.repayAmount = amount;\n        }\n\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n        // Note: this checks that repayAmount is less than borrowCurrent\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail gracefully if asset is not approved or has insufficient balance\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the customer is paying some of their borrow, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError != 0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                } \n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n        \n        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice users repay all or some of an underwater borrow and receive collateral\n     * @param targetAccount The account whose borrow should be liquidated\n     * @param assetBorrow The market asset to repay\n     * @param assetCollateral The borrower\u0027s market asset to receive in exchange\n     * @param requestedAmountClose The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) public isKYCVerifiedCustomer isLiquidator returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n        }\n        LiquidateLocalVars memory localResults;\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n        // We\u0027ll use localResults.liquidator inside this function for clarity vs using msg.sender.\n        localResults.targetAccount = targetAccount;\n        localResults.assetBorrow = assetBorrow;\n        localResults.liquidator = msg.sender;\n        localResults.assetCollateral = assetCollateral;\n\n        Market storage borrowMarket = markets[assetBorrow];\n        Market storage collateralMarket = markets[assetCollateral];\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n\n        // Liquidator might already hold some of the collateral asset\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n        Error err; // re-used for all intermediate errors\n\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n        if(err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n        }\n\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n        assert(err == Error.NO_ERROR);\n\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Liquidator may or may not already have some collateral asset.\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We update the protocol\u0027s totalSupply for assetCollateral in 2 steps, first by adding target user\u0027s accumulated\n        // interest and then by adding the liquidator\u0027s accumulated interest.\n\n        // Step 1 of 2: We add the target user\u0027s supplyCurrent and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the target user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Step 2 of 2: We add the liquidator\u0027s supplyCurrent of collateral asset and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the calling user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n        // This is equal to the lesser of\n        // 1. borrowCurrent; (already calculated)\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n        // discountedRepayToEvenAmount=\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n        // 3. discountedBorrowDenominatedCollateral\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n        (err, localResults.discountedBorrowDenominatedCollateral) =\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n        }\n\n        if (borrowMarket.isSupported) {\n            // Market is supported, so we calculate item 2 from above.\n            (err, localResults.discountedRepayToEvenAmount) =\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n            }\n\n            // We need to do a two-step min to select from all 3 values\n            // min1\u00263 = min(item 1, item 3)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n\n            // min1\u00263\u00262 = min(min1\u00263, 2)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n        } else {\n            // Market is not supported, so we don\u0027t need to calculate item 2.\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n        }\n\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (requestedAmountClose == uint(-1)) {\n            localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        } else {\n            localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n        }\n\n        // From here on, no more use of `requestedAmountClose`\n\n        // Verify closeBorrowAmount_TargetUnderwaterAsset \u003c= maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n        }\n\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n        }\n\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n        // Fail gracefully if asset is not approved or has insufficient balance\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We are going to repay the target user\u0027s borrow using the calling user\u0027s funds\n        // We update the protocol\u0027s totalBorrow for assetBorrow, by subtracting the target user\u0027s prior checkpointed balance,\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset \u003c= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can\u0027t underflow\n        assert(err == Error.NO_ERROR);\n\n        // We calculate the protocol\u0027s totalBorrow for assetBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n        // (Please note that we don\u0027t need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don\u0027t recalculate it.\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        // Now we look at collateral. We calculated target user\u0027s accumulated supply balance and the supply index above.\n        // Now we need to calculate the borrow index.\n        // We don\u0027t need to calculate new rates for the collateral asset because we have not changed utilization:\n        //  - accumulating interest on the target user\u0027s collateral does not change cash or borrows\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        // We checkpoint the target user\u0027s assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // The sub won\u0027t underflow because because seizeSupplyAmount_TargetCollateralAsset \u003c= target user\u0027s collateral balance\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n        assert (err == Error.NO_ERROR);\n\n        // We checkpoint the liquidating user\u0027s assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // We can\u0027t overflow here because if this would overflow, then we would have already overflowed above and failed\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n        assert (err == Error.NO_ERROR);\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n            }\n        } else {\n            uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if(supplyError !=0 ){\n                return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n            }\n        }\n\n        // Save borrow market updates\n        borrowMarket.blockNumber = getBlockNumber();\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n        // borrowMarket.totalSupply does not need to be updated\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        // Save collateral market updates\n        // We didn\u0027t calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n        collateralMarket.blockNumber = getBlockNumber();\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n\n        // Save user updates\n\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n        \n        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n\n        emitLiquidationEvent(localResults);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n     */\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n        emit BorrowLiquidated(localResults.targetAccount,\n            localResults.assetBorrow,\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n            localResults.liquidator,\n            localResults.assetCollateral,\n            localResults.startingSupplyBalance_TargetCollateralAsset,\n            localResults.currentSupplyBalance_TargetCollateralAsset,\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\n    }\n\n    /**\n     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n     *      If the market isn\u0027t supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n     */\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n        Error err;\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n        Exp memory accountShortfall_TargetUser;\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n        Exp memory discountedPrice_UnderwaterAsset;\n        Exp memory rawResult;\n\n        // we calculate the target user\u0027s shortfall, denominated in Ether, that the user is below the collateral ratio\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n        // discountedCollateralRatioMinusOne \u003c collateralRatio\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can\u0027t overflow either\n        assert(err == Error.NO_ERROR);\n\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n        // It\u0027s theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n    /**\n     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n     */\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n        Error err;\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n        Exp memory rawResult;\n\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n     */\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n\n        // re-used for all intermediate errors\n        Error err;\n\n        // (1+liquidationDiscount)\n        Exp memory liquidationMultiplier;\n\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n        // or, expanded:\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n        Exp memory finalNumerator;\n\n        // finalNumerator / priceCollateral\n        Exp memory rawResult;\n\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        // liquidation discount will be enforced \u003c 1, so 1 + liquidationDiscount can\u0027t overflow.\n        assert(err == Error.NO_ERROR);\n\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param asset The market asset to borrow\n     * @param amount The amount to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(address asset, uint amount) public isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n        }\n        BorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n\n        Error err;\n        uint rateCalculationResultCode;\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n        }\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Calculate origination fee.\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n        }\n        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow with fee\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // Check customer liquidity\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // Would the customer have a shortfall after this borrow (including origination fee)?\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] \u003e accountLiquidity`\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // Fail gracefully if protocol has insufficient cash\n        localResults.currentCash = getCash(asset);\n        // We need to calculate what the updated cash will be after we transfer out to the user\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            // Note: we ignore error here and call this token insufficient cash\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n\n        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n        uint originationFeeRepaid = 0;\n        if (originationFeeBalance[user][asset] != 0){\n            if (amount \u003c originationFeeBalance[user][asset]) {\n                originationFeeRepaid = amount;\n            } else {\n                originationFeeRepaid = originationFeeBalance[user][asset];\n            }\n            Balance storage balance = supplyBalances[admin][asset];\n\n            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n            Error err; // Re-used for every function call that includes an Error in its return value(s).\n\n            originationFeeBalance[user][asset] -= originationFeeRepaid;\n\n            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n\n            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n\n            // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n\n            // Save market updates\n            markets[asset].totalSupply =  localResults.newTotalSupply;\n\n            // Save user updates\n            localResults.startingBalance = balance.principal;\n            balance.principal = localResults.userSupplyUpdated;\n            balance.interestIndex = newSupplyIndex;\n\n            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n        }\n    }\n}"},"MoneyMarketV11.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./ChainLink.sol\";\nimport \"./AlkemiWETH.sol\";\n\ncontract MoneyMarketV11 is Exponential, SafeToken {\n\n    uint internal initialInterestIndex;\n    uint internal defaultOriginationFee; \n    uint internal defaultCollateralRatio;\n    uint internal defaultLiquidationDiscount;\n\n    uint internal minimumCollateralRatioMantissa;\n    uint internal maximumLiquidationDiscountMantissa;\n    bool public initializationDone; // To make sure initializer is called only once\n\n    /**\n     * @notice `MoneyMarket` is the core MoneyMarket contract\n     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n     * @notice Hence this contract has an \u0027initializer\u0027 in place of a \u0027constructor\u0027\n     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n     */\n    function initializer() public {\n        if(initializationDone == false) {\n            initializationDone = true;\n            admin = msg.sender;\n            initialInterestIndex = 10 ** 18;\n            defaultOriginationFee = (10 ** 15); // default is 0.1%\n            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n            originationFee = Exp({mantissa: defaultOriginationFee});\n            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n            // oracle must be configured via _setOracle\n        }\n    }\n\n    /**\n     * @notice Do not pay directly into MoneyMarket, please use `supply`.\n     */\n    function() payable public {\n        revert();\n    }\n\n    /**\n     * @dev pending Administrator for this contract.\n     */\n    address public pendingAdmin;\n\n    /**\n     * @dev Administrator for this contract. Initially set in constructor, but can\n     *      be changed by the admin itself.\n     */\n    address public admin;\n\n    /**\n     * @dev Managers for this contract with limited permissions. Can\n     *      be changed by the admin.\n     */\n    mapping (address =\u003e bool) public managers;\n\n    /**\n     * @dev Account allowed to set oracle prices for this contract. Initially set\n     *      in constructor, but can be changed by the admin.\n     */\n    address public oracle;\n\n    /**\n     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n     */\n    ChainLink priceOracle;\n\n    /**\n     * @dev Container for customer balance information written to storage.\n     *\n     *      struct Balance {\n     *        principal = customer total balance with accrued interest after applying the customer\u0027s most recent balance-changing action\n     *        interestIndex = the total interestIndex as calculated after applying the customer\u0027s most recent balance-changing action\n     *      }\n     */\n    struct Balance {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for supplies\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public supplyBalances;\n\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public borrowBalances;\n\n\n    /**\n     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n     *\n     *      struct Market {\n     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n     *         blockNumber = when the other values in this struct were calculated\n     *         totalSupply = total amount of this asset supplied (in asset wei)\n     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n     *     }\n     */\n    struct Market {\n        bool isSupported;\n        uint blockNumber;\n        InterestRateModel interestRateModel;\n\n        uint totalSupply;\n        uint supplyRateMantissa;\n        uint supplyIndex;\n\n        uint totalBorrows;\n        uint borrowRateMantissa;\n        uint borrowIndex;\n    }\n\n    /**\n     * @dev wethAddress to hold the WETH token contract address\n     * set using setWethAddress function\n     */\n    address public wethAddress;\n\n    /**\n     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n     */\n    AlkemiWETH public WETHContract;\n\n    /**\n     * @dev map: assetAddress -\u003e Market\n     */\n    mapping(address =\u003e Market) public markets;\n\n    /**\n     * @dev list: collateralMarkets\n     */\n    address[] public collateralMarkets;\n\n    /**\n     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n     *      is initially set in the constructor, but can be changed by the admin.\n     */\n    Exp public collateralRatio;\n\n    /**\n     * @dev originationFee for new borrows.\n     *\n     */\n    Exp public originationFee;\n\n    /**\n     * @dev liquidationDiscount for collateral when liquidating borrows\n     *\n     */\n    Exp public liquidationDiscount;\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    /**\n     * @dev Mapping to identify the list of KYC Admins\n     */\n    mapping(address=\u003ebool) private KYCAdmins;\n    /**\n     * @dev Mapping to identify the list of customers with verified KYC\n     */\n    mapping(address=\u003ebool) private customersWithKYC;\n\n    /**\n     * @dev Mapping to identify the list of customers with Liquidator roles\n     */\n    mapping(address=\u003ebool) private liquidators;\n\n    /**\n     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n    struct SupplyLocalVars {\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n    }\n\n    /**\n     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n\n    struct WithdrawLocalVars {\n        uint withdrawAmount;\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfWithdrawal;\n        uint withdrawCapacity;\n    }\n\n    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n    struct AccountValueLocalVars {\n        address assetAddress;\n        uint collateralMarketsLength;\n\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        Exp supplyTotalValue;\n        Exp sumSupplies;\n\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        Exp borrowTotalValue;\n        Exp sumBorrows;\n    }\n\n    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n    struct PayBorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint repayAmount;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n    }\n\n    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n    struct BorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint borrowAmountWithFee;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfBorrowAmountWithFee;\n    }\n\n    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n    struct LiquidateLocalVars {\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n        address targetAccount;\n        address assetBorrow;\n        address liquidator;\n        address assetCollateral;\n\n        // borrow index and supply index are global to the asset, not specific to the user\n        uint newBorrowIndex_UnderwaterAsset;\n        uint newSupplyIndex_UnderwaterAsset;\n        uint newBorrowIndex_CollateralAsset;\n        uint newSupplyIndex_CollateralAsset;\n\n        // the target borrow\u0027s full balance with accumulated interest\n        uint currentBorrowBalance_TargetUnderwaterAsset;\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\n\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\n\n        uint startingBorrowBalance_TargetUnderwaterAsset;\n        uint startingSupplyBalance_TargetCollateralAsset;\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\n\n        uint currentSupplyBalance_TargetCollateralAsset;\n        uint updatedSupplyBalance_TargetCollateralAsset;\n\n        // If liquidator already has a balance of collateralAsset, we will accumulate\n        // interest on it before transferring seized collateral from the borrower.\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\n        // This will be the liquidator\u0027s accumulated balance of collateral asset before the liquidation (if any)\n        // plus the amount seized from the borrower.\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n\n        uint newTotalSupply_ProtocolCollateralAsset;\n        uint currentCash_ProtocolUnderwaterAsset;\n        uint updatedCash_ProtocolUnderwaterAsset;\n\n        // cash does not change for collateral asset\n\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n\n        // Why no variables for the interest rates for the collateral asset?\n        // We don\u0027t need to calculate new rates for the collateral asset since neither cash nor borrows change\n\n        uint discountedRepayToEvenAmount;\n\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n        uint discountedBorrowDenominatedCollateral;\n\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        uint closeBorrowAmount_TargetUnderwaterAsset;\n        uint seizeSupplyAmount_TargetCollateralAsset;\n\n        Exp collateralPrice;\n        Exp underwaterAssetPrice;\n\n        uint reimburseAmount;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e originationFeeBalance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e uint)) public originationFeeBalance;\n\n    /**\n     * @dev Event emitted on successful addition of Weth Address\n     */\n    event WETHAddressSet(address wethAddress);\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event LiquidatorAdded(address Liquidator);\n    event LiquidatorRemoved(address Liquidator);\n\n    /**\n     * @dev emitted when a supply is received\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a origination fee supply is received as admin\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n    /**\n     * @dev emitted when a supply is withdrawn\n     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a new borrow is taken\n     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n     */\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is repaid\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is liquidated\n     *      targetAccount = user whose borrow was liquidated\n     *      assetBorrow = asset borrowed\n     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountRepaid = amount of borrow repaid\n     *      liquidator = account requesting the liquidation\n     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountSeized = amount of collateral seized by liquidator\n     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n     */\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    /**\n     * @dev emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev newOracle - address of new oracle\n     */\n    event NewOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev emitted when new market is supported by admin\n     */\n    event SupportedMarket(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when risk parameters are changed by admin\n     */\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n\n    /**\n     * @dev emitted when origination fee is changed by admin\n     */\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n\n    /**\n     * @dev emitted when market has new interest rate model set\n     */\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when admin withdraws equity\n     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n     */\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n\n    /**\n     * @dev emitted when a supported market is suspended by admin\n     */\n    event SuspendedMarket(address asset);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev KYC Integration\n     */\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event KYCAdminAdded(address KYCAdmin);\n    event KYCAdminRemoved(address KYCAdmin);\n    event KYCCustomerAdded(address KYCCustomer);\n    event KYCCustomerRemoved(address KYCCustomer);\n\n    /**\n     * @dev Modifier to check if the caller of the function is a manager or owner\n     */\n    modifier onlyAdminOrManager {\n        // Check caller = KYCadmin\n        require(msg.sender == admin || managers[msg.sender],\"Only owner or manager can perform operation\");\n        _;\n    }\n\n    /**\n     * @dev Function to emit fail event to frontend\n     */\n    function emitError(Error error, FailureInfo failure) private returns(uint) {\n        return fail(error, failure);\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is a KYC Admin\n     */\n    modifier isKYCAdmin {\n        // Check caller = KYCadmin\n        if (!KYCAdmins[msg.sender]) {\n            emitError(Error.KYC_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_CHECK_FAILED);\n        } else {\n            require(KYCAdmins[msg.sender],\"Operation can only be performed by a KYC Admin\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is KYC verified\n     */\n    modifier isKYCVerifiedCustomer {\n        // Check caller = KYCVerifiedCustomer\n        if (!customersWithKYC[msg.sender]) {\n            revertEtherToUser(msg.sender,msg.value);\n            emitError(Error.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED, FailureInfo.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED);\n        } else {\n            require(customersWithKYC[msg.sender],\"Customer is not KYC Verified\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add KYC Admins\n     */\n    function addKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = true;\n        emit KYCAdminAdded(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove KYC Admins\n     */\n    function removeKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = false;\n        emit KYCAdminRemoved(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to add KYC Customers\n     */\n    function addCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = true;\n        emit KYCCustomerAdded(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to remove KYC Customers\n     */\n    function removeCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = false;\n        emit KYCCustomerRemoved(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch KYC verification status of a customer\n     */\n    function verifyKYC(address customer) public view returns(bool) {\n        return customersWithKYC[customer];\n    }\n\n    /**\n     * @dev Function to fetch KYC Admin status of an admin\n     */\n    function checkKYCAdmin(address _KYCAdmin) public view returns(bool) {\n        return KYCAdmins[_KYCAdmin];\n    }\n\n    /**\n     * @dev Liquidator Integration\n     */\n\n    /**\n     * @dev Modifier to check if the caller of the function is a Liquidator\n     */\n    modifier isLiquidator {\n        // Check caller = Liquidator\n        if (!liquidators[msg.sender]) {\n            emitError(Error.LIQUIDATOR_CHECK_FAILED, FailureInfo.LIQUIDATOR_CHECK_FAILED);\n        } else {\n            require(liquidators[msg.sender],\"Customer is not a Liquidator\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add Liquidators\n     */\n    function addLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = true;\n        emit LiquidatorAdded(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove Liquidators\n     */\n    function removeLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = false;\n        emit LiquidatorRemoved(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch Liquidator status of a customer\n     */\n    function verifyLiquidator(address liquidator) public view returns(bool) {\n        return liquidators[liquidator];\n    }\n\n    /**\n     * @dev Simple function to calculate min between two numbers.\n     */\n    function min(uint a, uint b) pure internal returns (uint) {\n        if (a \u003c b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *      This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n     *      Note: this will not add the asset if it already exists.\n     */\n    function addCollateralMarket(address asset) internal {\n        for (uint i = 0; i \u003c collateralMarkets.length; i++) {\n            if (collateralMarkets[i] == asset) {\n                return;\n            }\n        }\n\n        collateralMarkets.push(asset);\n    }\n\n    /**\n     * @notice return the number of elements in `collateralMarkets`\n     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n     * @return the length of `collateralMarkets`\n     */\n    function getCollateralMarketsLength() public view returns (uint) {\n        return collateralMarkets.length;\n    }\n\n    /**\n     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n     */\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n\n        // Get the block delta\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        // Scale the interest rate times number of blocks\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n        if (err2 != Error.NO_ERROR) {\n            return (err2, 0);\n        }\n\n        // Then scale that accumulated interest by the old interest index to get the new interest index\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n        if (err3 != Error.NO_ERROR) {\n            return (err3, 0);\n        }\n\n        // Finally, truncate the interest index. This works only if interest index starts large enough\n        // that is can be accurately represented with a whole number.\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n    }\n\n    /**\n     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n     *      This is defined as: `The user\u0027s last balance checkpoint is multiplied by the currentSupplyIndex\n     *      value and divided by the user\u0027s checkpoint index value`\n     *\n     *      TODO: Is there a way to handle this that is less likely to overflow?\n     */\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n        if (startingBalance == 0) {\n            // We are accumulating interest on any previous balance; if there\u0027s no previous balance, then there is\n            // nothing to accumulate.\n            return (Error.NO_ERROR, 0);\n        }\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return div(balanceTimesIndex, interestIndexStart);\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset.\n     */\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n     */\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory scaledPrice;\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        // Now, multiply the assetValue by the collateral ratio\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        // Get the price for the given asset amount\n        return mulScalar(scaledPrice, assetAmount);\n    }\n\n    /**\n     * @dev Calculates the origination fee added to a given borrowAmount\n     *      This is simply `(1 + originationFee) * borrowAmount`\n     *\n     *      TODO: Track at what magnitude this fee rounds down to zero?\n     */\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n        // When origination fee is zero, the amount with fee is simply equal to the amount\n        if (isZeroExp(originationFee)) {\n            return (Error.NO_ERROR, borrowAmount);\n        }\n\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n    }\n\n    /**\n     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n     * @param asset asset whose price should be fetched\n     */\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n        if (oracle == address(0)) {\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n        }\n\n        uint priceMantissa = priceOracle.getAssetPrice(asset);\n\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n    }\n\n    /**\n     * @notice Reads scaled price of specified asset from the price oracle\n     * @dev Reads scaled price of specified asset from the price oracle.\n     *      The plural name is to match a previous storage mapping that this function replaced.\n     * @param asset Asset whose price should be retrieved\n     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return 0;\n        }\n        return result.mantissa;\n    }\n\n    /**\n     * @dev Gets the amount of the specified asset given the specified Eth value\n     *      ethValue / oraclePrice = assetAmountWei\n     *      If there\u0027s no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n     */\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory assetAmount;\n\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, assetAmount) = divExp(ethValue, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(assetAmount));\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller = pendingAdmin\n        // msg.sender can\u0027t be zero\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAdmin = admin;\n        // Store admin = pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = 0;\n\n        emit NewAdmin(oldAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new oracle, who can set asset prices\n     * @dev Admin function to change oracle\n     * @param newOracle New oracle address\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOracle(address newOracle) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n        }\n\n        // Verify contract at newOracle address supports assetPrices call.\n        // This will revert if it doesn\u0027t.\n        // ChainLink priceOracleTemp = ChainLink(newOracle);\n        // priceOracleTemp.getAssetPrice(address(0));\n\n        address oldOracle = oracle;\n\n        // Store oracle = newOracle\n        oracle = newOracle;\n        // Initialize the Chainlink contract in priceOracle\n        priceOracle = ChainLink(newOracle);\n\n        emit NewOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice returns the liquidity for given account.\n     *         a positive result indicates ability to borrow, whereas\n     *         a negative result indicates a shortfall which may be liquidated\n     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n     *      note: this includes interest trued up on all balances\n     * @param account the account to examine\n     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n     */\n    function getAccountLiquidity(address account) public view returns (int) {\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n        require(err == Error.NO_ERROR);\n\n        if (isZeroExp(accountLiquidity)) {\n            return -1 * int(truncate(accountShortfall));\n        } else {\n            return int(truncate(accountLiquidity));\n        }\n    }\n\n    /**\n     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose supply balance belonging to `account` should be checked\n     * @return uint supply balance on success, throws on failed assertion otherwise\n     */\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[account][asset];\n\n        // Calculate the newSupplyIndex, needed to calculate user\u0027s supplyCurrent\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n        require(err == Error.NO_ERROR);\n\n        return userSupplyCurrent;\n    }\n\n    /**\n     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n     * @return uint borrow balance on success, throws on failed assertion otherwise\n     */\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[account][asset];\n\n        // Calculate the newBorrowIndex, needed to calculate user\u0027s borrowCurrent\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n        require(err == Error.NO_ERROR);\n\n        return userBorrowCurrent;\n    }\n\n\n    /**\n     * @notice Supports a given market (asset) for use\n     * @dev Admin function to add support for a market\n     * @param asset Asset to support; MUST already have a non-zero price set\n     * @param interestRateModel InterestRateModel to use for the asset\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        // Append asset to collateralAssets if not set\n        addCollateralMarket(asset);\n\n        // Set market isSupported to true\n        markets[asset].isSupported = true;\n\n        // Default supply and borrow index to 1e18\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n\n        emit SupportedMarket(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Suspends a given *supported* market (asset) from use.\n     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n     * @dev Admin function to suspend a market\n     * @param asset Asset to suspend\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _suspendMarket(address asset) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n        }\n\n        // If the market is not configured at all, we don\u0027t want to add any configuration for it.\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n        // has already been marked as unsupported. We can just return without doing anything.\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n        if (!markets[asset].isSupported) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // If we get here, we know market is configured and is supported, so set isSupported to false\n        markets[asset].isSupported = false;\n\n        emit SuspendedMarket(asset);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n     * @dev Owner function to set the risk parameters\n     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be \u003c= 0.1 and must be less than (descaled collateral ratio minus 1)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n        }\n\n        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n\n        Error err;\n        Exp memory newLiquidationDiscountPlusOne;\n\n        // Make sure new collateral ratio value is not below minimum value\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n        // C \u003c L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Save current values so we can emit them in log.\n        Exp memory oldCollateralRatio = collateralRatio;\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\n\n        // Store new values\n        collateralRatio = newCollateralRatio;\n        liquidationDiscount = newLiquidationDiscount;\n\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the origination fee (which is a multiplier on new borrows)\n     * @dev Owner function to set the origination fee\n     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n        }\n\n        // Save current value so we can emit it in log.\n        Exp memory oldOriginationFee = originationFee;\n\n        originationFee = Exp({mantissa: originationFeeMantissa});\n\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the interest rate model for a given market\n     * @dev Admin function to set interest rate model\n     * @param asset Asset to support\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        emit SetMarketInterestRateModel(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` \u003c= equity. Equity= cash - (supply + borrows)\n     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount \u003c= cash - (supply + borrows)\n     * @param asset asset whose equity should be withdrawn\n     * @param amount amount of equity to withdraw; must not exceed equity available\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n        }\n\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n        uint cash = getCash(asset);\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n        if (err0 != Error.NO_ERROR) {\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n        }\n\n        if (amount \u003e equity) {\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset out of the protocol to the admin\n            Error err2 = doTransferOut(asset, admin, amount);\n            if (err2 != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n        emit EquityWithdrawn(asset, equity, amount, admin);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Set WETH token contract address\n     * @param wethContractAddress Enter the WETH token address\n     */\n    function setWethAddress(address wethContractAddress) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n        }\n        wethAddress = wethContractAddress;\n        WETHContract = AlkemiWETH(wethAddress);\n        emit WETHAddressSet(wethContractAddress);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n     * @return errors if any\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n        user; // To silence the warning of unused local variable\n        if(wethAddress != address(0)){\n            WETHContract.deposit.value(etherAmount)();\n            return uint(Error.NO_ERROR);\n        }\n        else {\n            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n        }\n    }\n\n    /**\n     * @dev Revert Ether paid by user back to user\u0027s account in case transaction fails due to some other reason\n     * @param etherAmount Amount of ether to be sent back to user\n     * @param user User account address\n     */\n    function revertEtherToUser(address user, uint etherAmount) internal {\n        if(etherAmount \u003e 0){\n            user.transfer(etherAmount);\n        }\n    }\n\n    /**\n     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n     * @dev add amount of supported asset to msg.sender\u0027s account\n     * @param asset The market asset to supply\n     * @param amount The amount to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function supply(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage balance = supplyBalances[msg.sender][asset];\n\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n        }\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // Fail gracefully if asset is not approved or has insufficient balance\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n        balance.principal = localResults.userSupplyUpdated;\n        balance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice withdraw `amount` of `ether` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `ether` from msg.sender\u0027s account to msg.sender\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n            WETHContract.withdraw(user,etherAmount);\n            return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice send Ether from contract to a user\n     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n     */\n    function sendEtherToUser(address user, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n        }\n        user.transfer(amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraw `amount` of `asset` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `asset` from msg.sender\u0027s account to msg.sender\n     * @param asset The market asset to withdraw\n     * @param requestedAmount The amount to withdraw (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function withdraw(address asset, uint requestedAmount) public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // We calculate the user\u0027s accountLiquidity and accountShortfall.\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount =\u003e the lesser of withdrawCapacity and supplyCurrent\n        if (requestedAmount == uint(-1)) {\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n            }\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n        } else {\n            localResults.withdrawAmount = requestedAmount;\n        }\n\n        // From here on we should NOT use requestedAmount.\n\n        // Fail gracefully if protocol has insufficient cash\n        // If protocol has insufficient cash, the sub operation will underflow.\n        localResults.currentCash = getCash(asset);\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        // We check that the amount is less than or equal to supplyCurrent\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // We want to know the user\u0027s withdrawCapacity, denominated in the asset\n        // Customer\u0027s withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply.\n        // Note that, even though the customer is withdrawing, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // failure\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n        supplyBalance.principal = localResults.userSupplyUpdated;\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n        \n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Gets the user\u0027s account liquidity and account shortfall balances. This includes\n     *      any accumulated interest thus far but does NOT actually update anything in\n     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n     */\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n        Error err;\n        uint sumSupplyValuesMantissa;\n        uint sumBorrowValuesMantissa;\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        Exp memory result;\n\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // if sumSupplies \u003c sumBorrows, then the user is under collateralized and has account shortfall.\n        // else the user meets the collateral ratio and has account liquidity.\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n            // accountShortfall = borrows - supplies\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n        } else {\n            // accountLiquidity = supplies - borrows\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n        }\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n     * TODO: To help save gas we could think about using the current Market.interestIndex\n     *       accumulate interest rather than calculating it\n     */\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n\n        /** By definition, all collateralMarkets are those that contribute to the user\u0027s\n         * liquidity and shortfall so we need only loop through those markets.\n         * To handle avoiding intermediate negative results, we will sum all the user\u0027s\n         * supply balances and borrow balances (with collateral ratio) separately and then\n         * subtract the sums at the end.\n         */\n\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n        localResults.sumSupplies = Exp({mantissa: 0});\n        localResults.sumBorrows = Exp({mantissa: 0});\n        Error err; // Re-used for all intermediate errors\n        localResults.collateralMarketsLength = collateralMarkets.length;\n\n        for (uint i = 0; i \u003c localResults.collateralMarketsLength; i++) {\n            localResults.assetAddress = collateralMarkets[i];\n            Market storage currentMarket = markets[localResults.assetAddress];\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n\n            if (supplyBalance.principal \u003e 0) {\n                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // We have the user\u0027s supply balance with interest so let\u0027s multiply by the asset price to get the total value\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of supplies\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n\n            if (borrowBalance.principal \u003e 0) {\n                // We perform a similar actions to get the user\u0027s borrow balance\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of borrows\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n        }\n\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n     *          sum ETH value of supplies scaled by 10e18,\n     *          sum ETH value of borrows scaled by 10e18)\n     */\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n\n            return (uint(err), 0, 0);\n        }\n\n        return (0, supplyValue, borrowValue);\n    }\n\n    /**\n     * @notice Users repay borrowed assets from their own address to the protocol.\n     * @param asset The market asset to repay\n     * @param amount The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(address asset, uint amount) public payable returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n        }\n        PayBorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n        Error err;\n        uint rateCalculationResultCode;\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        uint reimburseAmount;\n        // If the user specifies -1 amount to repay (“max”), repayAmount =\u003e\n        // the lesser of the senders ERC-20 balance and borrowCurrent\n        if (asset != wethAddress) {\n            if (amount == uint(-1)) {\n                localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n            } else {\n                localResults.repayAmount = amount;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (amount \u003e localResults.userBorrowCurrent) {\n                localResults.repayAmount = localResults.userBorrowCurrent;\n                (err, reimburseAmount) = sub(amount,localResults.userBorrowCurrent); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.repayAmount = amount;\n            }\n        }\n\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n        // Note: this checks that repayAmount is less than borrowCurrent\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail gracefully if asset is not approved or has insufficient balance\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the customer is paying some of their borrow, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,localResults.repayAmount);\n                //Repay excess funds\n                if(reimburseAmount \u003e 0){\n                    revertEtherToUser(msg.sender,reimburseAmount);\n                }\n                if(supplyError != 0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                } \n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n        \n        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice users repay all or some of an underwater borrow and receive collateral\n     * @param targetAccount The account whose borrow should be liquidated\n     * @param assetBorrow The market asset to repay\n     * @param assetCollateral The borrower\u0027s market asset to receive in exchange\n     * @param requestedAmountClose The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) public isLiquidator returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n        }\n        LiquidateLocalVars memory localResults;\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n        // We\u0027ll use localResults.liquidator inside this function for clarity vs using msg.sender.\n        localResults.targetAccount = targetAccount;\n        localResults.assetBorrow = assetBorrow;\n        localResults.liquidator = msg.sender;\n        localResults.assetCollateral = assetCollateral;\n\n        Market storage borrowMarket = markets[assetBorrow];\n        Market storage collateralMarket = markets[assetCollateral];\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n\n        // Liquidator might already hold some of the collateral asset\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n        Error err; // re-used for all intermediate errors\n\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n        if(err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n        }\n\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n        assert(err == Error.NO_ERROR);\n\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Liquidator may or may not already have some collateral asset.\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We update the protocol\u0027s totalSupply for assetCollateral in 2 steps, first by adding target user\u0027s accumulated\n        // interest and then by adding the liquidator\u0027s accumulated interest.\n\n        // Step 1 of 2: We add the target user\u0027s supplyCurrent and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the target user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Step 2 of 2: We add the liquidator\u0027s supplyCurrent of collateral asset and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the calling user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n        // This is equal to the lesser of\n        // 1. borrowCurrent; (already calculated)\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n        // discountedRepayToEvenAmount=\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n        // 3. discountedBorrowDenominatedCollateral\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n        (err, localResults.discountedBorrowDenominatedCollateral) =\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n        }\n\n        if (borrowMarket.isSupported) {\n            // Market is supported, so we calculate item 2 from above.\n            (err, localResults.discountedRepayToEvenAmount) =\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n            }\n\n            // We need to do a two-step min to select from all 3 values\n            // min1\u00263 = min(item 1, item 3)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n\n            // min1\u00263\u00262 = min(min1\u00263, 2)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n        } else {\n            // Market is not supported, so we don\u0027t need to calculate item 2.\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n        }\n\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (assetBorrow != wethAddress) {\n            if (requestedAmountClose == uint(-1)) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (requestedAmountClose \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n                (err, localResults.reimburseAmount) = sub(requestedAmountClose,localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        }\n\n        // From here on, no more use of `requestedAmountClose`\n\n        // Verify closeBorrowAmount_TargetUnderwaterAsset \u003c= maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n        }\n\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n        }\n\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n        // Fail gracefully if asset is not approved or has insufficient balance\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We are going to repay the target user\u0027s borrow using the calling user\u0027s funds\n        // We update the protocol\u0027s totalBorrow for assetBorrow, by subtracting the target user\u0027s prior checkpointed balance,\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset \u003c= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can\u0027t underflow\n        assert(err == Error.NO_ERROR);\n\n        // We calculate the protocol\u0027s totalBorrow for assetBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n        // (Please note that we don\u0027t need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don\u0027t recalculate it.\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        // Now we look at collateral. We calculated target user\u0027s accumulated supply balance and the supply index above.\n        // Now we need to calculate the borrow index.\n        // We don\u0027t need to calculate new rates for the collateral asset because we have not changed utilization:\n        //  - accumulating interest on the target user\u0027s collateral does not change cash or borrows\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        // We checkpoint the target user\u0027s assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // The sub won\u0027t underflow because because seizeSupplyAmount_TargetCollateralAsset \u003c= target user\u0027s collateral balance\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n        assert (err == Error.NO_ERROR);\n\n        // We checkpoint the liquidating user\u0027s assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // We can\u0027t overflow here because if this would overflow, then we would have already overflowed above and failed\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n        assert (err == Error.NO_ERROR);\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n            }\n        } else {\n            uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            //Repay excess funds\n                if(localResults.reimburseAmount \u003e 0){\n                    revertEtherToUser(localResults.liquidator,localResults.reimburseAmount);\n                }\n            if(supplyError !=0 ){\n                return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n            }\n        }\n\n        // Save borrow market updates\n        borrowMarket.blockNumber = getBlockNumber();\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n        // borrowMarket.totalSupply does not need to be updated\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        // Save collateral market updates\n        // We didn\u0027t calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n        collateralMarket.blockNumber = getBlockNumber();\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n\n        // Save user updates\n\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n        \n        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n\n        emitLiquidationEvent(localResults);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n     */\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n        emit BorrowLiquidated(localResults.targetAccount,\n            localResults.assetBorrow,\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n            localResults.liquidator,\n            localResults.assetCollateral,\n            localResults.startingSupplyBalance_TargetCollateralAsset,\n            localResults.currentSupplyBalance_TargetCollateralAsset,\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\n    }\n\n    /**\n     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n     *      If the market isn\u0027t supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n     */\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n        Error err;\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n        Exp memory accountShortfall_TargetUser;\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n        Exp memory discountedPrice_UnderwaterAsset;\n        Exp memory rawResult;\n\n        // we calculate the target user\u0027s shortfall, denominated in Ether, that the user is below the collateral ratio\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n        // discountedCollateralRatioMinusOne \u003c collateralRatio\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can\u0027t overflow either\n        assert(err == Error.NO_ERROR);\n\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n        // It\u0027s theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n    /**\n     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n     */\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n        Error err;\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n        Exp memory rawResult;\n\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n     */\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n\n        // re-used for all intermediate errors\n        Error err;\n\n        // (1+liquidationDiscount)\n        Exp memory liquidationMultiplier;\n\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n        // or, expanded:\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n        Exp memory finalNumerator;\n\n        // finalNumerator / priceCollateral\n        Exp memory rawResult;\n\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        // liquidation discount will be enforced \u003c 1, so 1 + liquidationDiscount can\u0027t overflow.\n        assert(err == Error.NO_ERROR);\n\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param asset The market asset to borrow\n     * @param amount The amount to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(address asset, uint amount) public isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n        }\n        BorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n\n        Error err;\n        uint rateCalculationResultCode;\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n        }\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Calculate origination fee.\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n        }\n        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow with fee\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // Check customer liquidity\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // Would the customer have a shortfall after this borrow (including origination fee)?\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] \u003e accountLiquidity`\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // Fail gracefully if protocol has insufficient cash\n        localResults.currentCash = getCash(asset);\n        // We need to calculate what the updated cash will be after we transfer out to the user\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            // Note: we ignore error here and call this token insufficient cash\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n\n        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n        uint originationFeeRepaid = 0;\n        if (originationFeeBalance[user][asset] != 0){\n            if (amount \u003c originationFeeBalance[user][asset]) {\n                originationFeeRepaid = amount;\n            } else {\n                originationFeeRepaid = originationFeeBalance[user][asset];\n            }\n            Balance storage balance = supplyBalances[admin][asset];\n\n            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n            Error err; // Re-used for every function call that includes an Error in its return value(s).\n\n            originationFeeBalance[user][asset] -= originationFeeRepaid;\n\n            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n\n            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n\n            // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n\n            // Save market updates\n            markets[asset].totalSupply =  localResults.newTotalSupply;\n\n            // Save user updates\n            localResults.startingBalance = balance.principal;\n            balance.principal = localResults.userSupplyUpdated;\n            balance.interestIndex = newSupplyIndex;\n\n            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n        }\n    }\n}"},"MoneyMarketV12.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./SafeToken.sol\";\nimport \"./ChainLink.sol\";\nimport \"./AlkemiWETH.sol\";\n\ncontract MoneyMarketV12 is Exponential, SafeToken {\n\n    uint internal initialInterestIndex;\n    uint internal defaultOriginationFee; \n    uint internal defaultCollateralRatio;\n    uint internal defaultLiquidationDiscount;\n\n    uint internal minimumCollateralRatioMantissa;\n    uint internal maximumLiquidationDiscountMantissa;\n    bool public initializationDone; // To make sure initializer is called only once\n\n    /**\n     * @notice `MoneyMarket` is the core MoneyMarket contract\n     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n     * @notice Hence this contract has an \u0027initializer\u0027 in place of a \u0027constructor\u0027\n     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n     */\n    function initializer() public {\n        if(initializationDone == false) {\n            initializationDone = true;\n            admin = msg.sender;\n            initialInterestIndex = 10 ** 18;\n            defaultOriginationFee = (10 ** 15); // default is 0.1%\n            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n            originationFee = Exp({mantissa: defaultOriginationFee});\n            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n            // oracle must be configured via _setOracle\n        }\n    }\n\n    /**\n     * @notice Do not pay directly into MoneyMarket, please use `supply`.\n     */\n    function() payable public {\n        revert();\n    }\n\n    /**\n     * @dev pending Administrator for this contract.\n     */\n    address public pendingAdmin;\n\n    /**\n     * @dev Administrator for this contract. Initially set in constructor, but can\n     *      be changed by the admin itself.\n     */\n    address public admin;\n\n    /**\n     * @dev Managers for this contract with limited permissions. Can\n     *      be changed by the admin.\n     */\n    mapping (address =\u003e bool) public managers;\n\n    /**\n     * @dev Account allowed to set oracle prices for this contract. Initially set\n     *      in constructor, but can be changed by the admin.\n     */\n    address public oracle;\n\n    /**\n     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n     */\n    ChainLink priceOracle;\n\n    /**\n     * @dev Container for customer balance information written to storage.\n     *\n     *      struct Balance {\n     *        principal = customer total balance with accrued interest after applying the customer\u0027s most recent balance-changing action\n     *        interestIndex = the total interestIndex as calculated after applying the customer\u0027s most recent balance-changing action\n     *      }\n     */\n    struct Balance {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for supplies\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public supplyBalances;\n\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e balance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e Balance)) public borrowBalances;\n\n\n    /**\n     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n     *\n     *      struct Market {\n     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n     *         blockNumber = when the other values in this struct were calculated\n     *         totalSupply = total amount of this asset supplied (in asset wei)\n     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n     *     }\n     */\n    struct Market {\n        bool isSupported;\n        uint blockNumber;\n        InterestRateModel interestRateModel;\n\n        uint totalSupply;\n        uint supplyRateMantissa;\n        uint supplyIndex;\n\n        uint totalBorrows;\n        uint borrowRateMantissa;\n        uint borrowIndex;\n    }\n\n    /**\n     * @dev wethAddress to hold the WETH token contract address\n     * set using setWethAddress function\n     */\n    address public wethAddress;\n\n    /**\n     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n     */\n    AlkemiWETH public WETHContract;\n\n    /**\n     * @dev map: assetAddress -\u003e Market\n     */\n    mapping(address =\u003e Market) public markets;\n\n    /**\n     * @dev list: collateralMarkets\n     */\n    address[] public collateralMarkets;\n\n    /**\n     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n     *      is initially set in the constructor, but can be changed by the admin.\n     */\n    Exp public collateralRatio;\n\n    /**\n     * @dev originationFee for new borrows.\n     *\n     */\n    Exp public originationFee;\n\n    /**\n     * @dev liquidationDiscount for collateral when liquidating borrows\n     *\n     */\n    Exp public liquidationDiscount;\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    /**\n     * @dev Mapping to identify the list of KYC Admins\n     */\n    mapping(address=\u003ebool) private KYCAdmins;\n    /**\n     * @dev Mapping to identify the list of customers with verified KYC\n     */\n    mapping(address=\u003ebool) private customersWithKYC;\n\n    /**\n     * @dev Mapping to identify the list of customers with Liquidator roles\n     */\n    mapping(address=\u003ebool) private liquidators;\n\n    /**\n     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n    struct SupplyLocalVars {\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n    }\n\n    /**\n     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n     *\n     * To avoid solidity limits on the number of local variables we:\n     * 1. Use a struct to hold local computation localResults\n     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n     *    requires either both to be declared inline or both to be previously declared.\n     * 3. Re-use a boolean error-like return variable.\n     */\n\n    struct WithdrawLocalVars {\n        uint withdrawAmount;\n        uint startingBalance;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        uint userSupplyUpdated;\n        uint newTotalSupply;\n        uint currentCash;\n        uint updatedCash;\n        uint newSupplyRateMantissa;\n        uint newBorrowIndex;\n        uint newBorrowRateMantissa;\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfWithdrawal;\n        uint withdrawCapacity;\n    }\n\n    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n    struct AccountValueLocalVars {\n        address assetAddress;\n        uint collateralMarketsLength;\n\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n        Exp supplyTotalValue;\n        Exp sumSupplies;\n\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        Exp borrowTotalValue;\n        Exp sumBorrows;\n    }\n\n    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n    struct PayBorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint repayAmount;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n    }\n\n    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n    struct BorrowLocalVars {\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n        uint borrowAmountWithFee;\n\n        uint userBorrowUpdated;\n        uint newTotalBorrows;\n        uint currentCash;\n        uint updatedCash;\n\n        uint newSupplyIndex;\n        uint newSupplyRateMantissa;\n        uint newBorrowRateMantissa;\n\n        uint startingBalance;\n\n        Exp accountLiquidity;\n        Exp accountShortfall;\n        Exp ethValueOfBorrowAmountWithFee;\n    }\n\n    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n    struct LiquidateLocalVars {\n        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n        address targetAccount;\n        address assetBorrow;\n        address liquidator;\n        address assetCollateral;\n\n        // borrow index and supply index are global to the asset, not specific to the user\n        uint newBorrowIndex_UnderwaterAsset;\n        uint newSupplyIndex_UnderwaterAsset;\n        uint newBorrowIndex_CollateralAsset;\n        uint newSupplyIndex_CollateralAsset;\n\n        // the target borrow\u0027s full balance with accumulated interest\n        uint currentBorrowBalance_TargetUnderwaterAsset;\n        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n        uint updatedBorrowBalance_TargetUnderwaterAsset;\n\n        uint newTotalBorrows_ProtocolUnderwaterAsset;\n\n        uint startingBorrowBalance_TargetUnderwaterAsset;\n        uint startingSupplyBalance_TargetCollateralAsset;\n        uint startingSupplyBalance_LiquidatorCollateralAsset;\n\n        uint currentSupplyBalance_TargetCollateralAsset;\n        uint updatedSupplyBalance_TargetCollateralAsset;\n\n        // If liquidator already has a balance of collateralAsset, we will accumulate\n        // interest on it before transferring seized collateral from the borrower.\n        uint currentSupplyBalance_LiquidatorCollateralAsset;\n        // This will be the liquidator\u0027s accumulated balance of collateral asset before the liquidation (if any)\n        // plus the amount seized from the borrower.\n        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n\n        uint newTotalSupply_ProtocolCollateralAsset;\n        uint currentCash_ProtocolUnderwaterAsset;\n        uint updatedCash_ProtocolUnderwaterAsset;\n\n        // cash does not change for collateral asset\n\n        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n\n        // Why no variables for the interest rates for the collateral asset?\n        // We don\u0027t need to calculate new rates for the collateral asset since neither cash nor borrows change\n\n        uint discountedRepayToEvenAmount;\n\n        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n        uint discountedBorrowDenominatedCollateral;\n\n        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n        uint closeBorrowAmount_TargetUnderwaterAsset;\n        uint seizeSupplyAmount_TargetCollateralAsset;\n\n        Exp collateralPrice;\n        Exp underwaterAssetPrice;\n\n        uint reimburseAmount;\n    }\n\n    /**\n     * @dev 2-level map: customerAddress -\u003e assetAddress -\u003e originationFeeBalance for borrows\n     */\n    mapping(address =\u003e mapping(address =\u003e uint)) public originationFeeBalance;\n\n    /**\n     * @dev Event emitted on successful addition of Weth Address\n     */\n    event WETHAddressSet(address wethAddress);\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event LiquidatorAdded(address Liquidator);\n    event LiquidatorRemoved(address Liquidator);\n\n    /**\n     * @dev emitted when a supply is received\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a origination fee supply is received as admin\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n    /**\n     * @dev emitted when a supply is withdrawn\n     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a new borrow is taken\n     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n     */\n    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is repaid\n     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n     */\n    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n\n    /**\n     * @dev emitted when a borrow is liquidated\n     *      targetAccount = user whose borrow was liquidated\n     *      assetBorrow = asset borrowed\n     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountRepaid = amount of borrow repaid\n     *      liquidator = account requesting the liquidation\n     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n     *      amountSeized = amount of collateral seized by liquidator\n     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n     */\n    event BorrowLiquidated(address targetAccount,\n        address assetBorrow,\n        uint borrowBalanceBefore,\n        uint borrowBalanceAccumulated,\n        uint amountRepaid,\n        uint borrowBalanceAfter,\n        address liquidator,\n        address assetCollateral,\n        uint collateralBalanceBefore,\n        uint collateralBalanceAccumulated,\n        uint amountSeized,\n        uint collateralBalanceAfter);\n\n    /**\n     * @dev emitted when pendingAdmin is changed\n     */\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n    /**\n     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n     */\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /**\n     * @dev newOracle - address of new oracle\n     */\n    event NewOracle(address oldOracle, address newOracle);\n\n    /**\n     * @dev emitted when new market is supported by admin\n     */\n    event SupportedMarket(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when risk parameters are changed by admin\n     */\n    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n\n    /**\n     * @dev emitted when origination fee is changed by admin\n     */\n    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n\n    /**\n     * @dev emitted when market has new interest rate model set\n     */\n    event SetMarketInterestRateModel(address asset, address interestRateModel);\n\n    /**\n     * @dev emitted when admin withdraws equity\n     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n     */\n    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n\n    /**\n     * @dev emitted when a supported market is suspended by admin\n     */\n    event SuspendedMarket(address asset);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev KYC Integration\n     */\n\n    /**\n     * @dev Events to notify the frontend of all the functions below\n     */\n    event KYCAdminAdded(address KYCAdmin);\n    event KYCAdminRemoved(address KYCAdmin);\n    event KYCCustomerAdded(address KYCCustomer);\n    event KYCCustomerRemoved(address KYCCustomer);\n\n    /**\n     * @dev Modifier to check if the caller of the function is a manager or owner\n     */\n    modifier onlyAdminOrManager {\n        // Check caller = KYCadmin\n        require(msg.sender == admin || managers[msg.sender],\"Only owner or manager can perform operation\");\n        _;\n    }\n\n    /**\n     * @dev Function to emit fail event to frontend\n     */\n    function emitError(Error error, FailureInfo failure) private returns(uint) {\n        return fail(error, failure);\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is a KYC Admin\n     */\n    modifier isKYCAdmin {\n        // Check caller = KYCadmin\n        if (!KYCAdmins[msg.sender]) {\n            emitError(Error.KYC_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_CHECK_FAILED);\n        } else {\n            require(KYCAdmins[msg.sender],\"Operation can only be performed by a KYC Admin\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Modifier to check if the caller of the function is KYC verified\n     */\n    modifier isKYCVerifiedCustomer {\n        // Check caller = KYCVerifiedCustomer\n        if (!customersWithKYC[msg.sender]) {\n            revertEtherToUser(msg.sender,msg.value);\n            emitError(Error.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED, FailureInfo.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED);\n        } else {\n            require(customersWithKYC[msg.sender],\"Customer is not KYC Verified\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add KYC Admins\n     */\n    function addKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = true;\n        emit KYCAdminAdded(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove KYC Admins\n     */\n    function removeKYCAdmin(address KYCAdmin) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        KYCAdmins[KYCAdmin] = false;\n        emit KYCAdminRemoved(KYCAdmin);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to add KYC Customers\n     */\n    function addCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = true;\n        emit KYCCustomerAdded(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the KYC admins to remove KYC Customers\n     */\n    function removeCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n        customersWithKYC[customer] = false;\n        emit KYCCustomerRemoved(customer);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch KYC verification status of a customer\n     */\n    function verifyKYC(address customer) public view returns(bool) {\n        return customersWithKYC[customer];\n    }\n\n    /**\n     * @dev Function to fetch KYC Admin status of an admin\n     */\n    function checkKYCAdmin(address _KYCAdmin) public view returns(bool) {\n        return KYCAdmins[_KYCAdmin];\n    }\n\n    /**\n     * @dev Liquidator Integration\n     */\n\n    /**\n     * @dev Modifier to check if the caller of the function is a Liquidator\n     */\n    modifier isLiquidator {\n        // Check caller = Liquidator\n        if (!liquidators[msg.sender]) {\n            emitError(Error.LIQUIDATOR_CHECK_FAILED, FailureInfo.LIQUIDATOR_CHECK_FAILED);\n        } else {\n            require(liquidators[msg.sender],\"Customer is not a Liquidator\");\n            _;\n        }\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to add Liquidators\n     */\n    function addLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = true;\n        emit LiquidatorAdded(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function for use by the admin of the contract to remove Liquidators\n     */\n    function removeLiquidator(address liquidator) public returns(uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n        }\n        liquidators[liquidator] = false;\n        emit LiquidatorRemoved(liquidator);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Function to fetch Liquidator status of a customer\n     */\n    function verifyLiquidator(address liquidator) public view returns(bool) {\n        return liquidators[liquidator];\n    }\n\n    /**\n     * @dev Simple function to calculate min between two numbers.\n     */\n    function min(uint a, uint b) pure internal returns (uint) {\n        if (a \u003c b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    /**\n     * @dev Function to simply retrieve block number\n     *      This exists mainly for inheriting test contracts to stub this result.\n     */\n    function getBlockNumber() internal view returns (uint) {\n        return block.number;\n    }\n\n    /**\n     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n     *      Note: this will not add the asset if it already exists.\n     */\n    function addCollateralMarket(address asset) internal {\n        for (uint i = 0; i \u003c collateralMarkets.length; i++) {\n            if (collateralMarkets[i] == asset) {\n                return;\n            }\n        }\n\n        collateralMarkets.push(asset);\n    }\n\n    /**\n     * @notice return the number of elements in `collateralMarkets`\n     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n     * @return the length of `collateralMarkets`\n     */\n    function getCollateralMarketsLength() public view returns (uint) {\n        return collateralMarkets.length;\n    }\n\n    /**\n     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n     */\n    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n\n        // Get the block delta\n        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        // Scale the interest rate times number of blocks\n        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n        if (err2 != Error.NO_ERROR) {\n            return (err2, 0);\n        }\n\n        // Then scale that accumulated interest by the old interest index to get the new interest index\n        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n        if (err3 != Error.NO_ERROR) {\n            return (err3, 0);\n        }\n\n        // Finally, truncate the interest index. This works only if interest index starts large enough\n        // that is can be accurately represented with a whole number.\n        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n    }\n\n    /**\n     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n     *      This is defined as: `The user\u0027s last balance checkpoint is multiplied by the currentSupplyIndex\n     *      value and divided by the user\u0027s checkpoint index value`\n     *\n     *      TODO: Is there a way to handle this that is less likely to overflow?\n     */\n    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n        if (startingBalance == 0) {\n            // We are accumulating interest on any previous balance; if there\u0027s no previous balance, then there is\n            // nothing to accumulate.\n            return (Error.NO_ERROR, 0);\n        }\n        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return div(balanceTimesIndex, interestIndexStart);\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset.\n     */\n    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n    }\n\n    /**\n     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n     */\n    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory scaledPrice;\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n        }\n\n        // Now, multiply the assetValue by the collateral ratio\n        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}));\n        }\n\n        // Get the price for the given asset amount\n        return mulScalar(scaledPrice, assetAmount);\n    }\n\n    /**\n     * @dev Calculates the origination fee added to a given borrowAmount\n     *      This is simply `(1 + originationFee) * borrowAmount`\n     *\n     *      TODO: Track at what magnitude this fee rounds down to zero?\n     */\n    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n        // When origination fee is zero, the amount with fee is simply equal to the amount\n        if (isZeroExp(originationFee)) {\n            return (Error.NO_ERROR, borrowAmount);\n        }\n\n        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n        if (err0 != Error.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n        if (err1 != Error.NO_ERROR) {\n            return (err1, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n    }\n\n    /**\n     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n     * @param asset asset whose price should be fetched\n     */\n    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n        if (oracle == address(0)) {\n            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n        }\n\n        uint priceMantissa = priceOracle.getAssetPrice(asset);\n\n        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n    }\n\n    /**\n     * @notice Reads scaled price of specified asset from the price oracle\n     * @dev Reads scaled price of specified asset from the price oracle.\n     *      The plural name is to match a previous storage mapping that this function replaced.\n     * @param asset Asset whose price should be retrieved\n     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        (Error err, Exp memory result) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return 0;\n        }\n        return result.mantissa;\n    }\n\n    /**\n     * @dev Gets the amount of the specified asset given the specified Eth value\n     *      ethValue / oraclePrice = assetAmountWei\n     *      If there\u0027s no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n     */\n    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n        Error err;\n        Exp memory assetPrice;\n        Exp memory assetAmount;\n\n        (err, assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, assetAmount) = divExp(ethValue, assetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(assetAmount));\n    }\n\n    /**\n     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n     * @param newPendingAdmin New pending admin.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n     */\n    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n     * @dev Admin function for pending admin to accept role and update admin\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _acceptAdmin() public returns (uint) {\n        // Check caller = pendingAdmin\n        // msg.sender can\u0027t be zero\n        if (msg.sender != pendingAdmin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAdmin = admin;\n        // Store admin = pendingAdmin\n        admin = pendingAdmin;\n        // Clear the pending value\n        pendingAdmin = 0;\n\n        emit NewAdmin(oldAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new oracle, who can set asset prices\n     * @dev Admin function to change oracle\n     * @param newOracle New oracle address\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOracle(address newOracle) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n        }\n\n        // Verify contract at newOracle address supports assetPrices call.\n        // This will revert if it doesn\u0027t.\n        // ChainLink priceOracleTemp = ChainLink(newOracle);\n        // priceOracleTemp.getAssetPrice(address(0));\n\n        address oldOracle = oracle;\n\n        // Store oracle = newOracle\n        oracle = newOracle;\n        // Initialize the Chainlink contract in priceOracle\n        priceOracle = ChainLink(newOracle);\n\n        emit NewOracle(oldOracle, newOracle);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice returns the liquidity for given account.\n     *         a positive result indicates ability to borrow, whereas\n     *         a negative result indicates a shortfall which may be liquidated\n     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n     *      note: this includes interest trued up on all balances\n     * @param account the account to examine\n     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n     */\n    function getAccountLiquidity(address account) public view returns (int) {\n        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n        require(err == Error.NO_ERROR);\n\n        if (isZeroExp(accountLiquidity)) {\n            return -1 * int(truncate(accountShortfall));\n        } else {\n            return int(truncate(accountLiquidity));\n        }\n    }\n\n    /**\n     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose supply balance belonging to `account` should be checked\n     * @return uint supply balance on success, throws on failed assertion otherwise\n     */\n    function getSupplyBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newSupplyIndex;\n        uint userSupplyCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[account][asset];\n\n        // Calculate the newSupplyIndex, needed to calculate user\u0027s supplyCurrent\n        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n        require(err == Error.NO_ERROR);\n\n        return userSupplyCurrent;\n    }\n\n    /**\n     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n     * @param account the account to examine\n     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n     * @return uint borrow balance on success, throws on failed assertion otherwise\n     */\n    function getBorrowBalance(address account, address asset) view public returns (uint) {\n        Error err;\n        uint newBorrowIndex;\n        uint userBorrowCurrent;\n\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[account][asset];\n\n        // Calculate the newBorrowIndex, needed to calculate user\u0027s borrowCurrent\n        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        require(err == Error.NO_ERROR);\n\n        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n        require(err == Error.NO_ERROR);\n\n        return userBorrowCurrent;\n    }\n\n\n    /**\n     * @notice Supports a given market (asset) for use\n     * @dev Admin function to add support for a market\n     * @param asset Asset to support; MUST already have a non-zero price set\n     * @param interestRateModel InterestRateModel to use for the asset\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n        }\n\n        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n        }\n\n        if (isZeroExp(assetPrice)) {\n            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        // Append asset to collateralAssets if not set\n        addCollateralMarket(asset);\n\n        // Set market isSupported to true\n        markets[asset].isSupported = true;\n\n        // Default supply and borrow index to 1e18\n        if (markets[asset].supplyIndex == 0) {\n            markets[asset].supplyIndex = initialInterestIndex;\n        }\n\n        if (markets[asset].borrowIndex == 0) {\n            markets[asset].borrowIndex = initialInterestIndex;\n        }\n\n        emit SupportedMarket(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Suspends a given *supported* market (asset) from use.\n     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n     * @dev Admin function to suspend a market\n     * @param asset Asset to suspend\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _suspendMarket(address asset) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n        }\n\n        // If the market is not configured at all, we don\u0027t want to add any configuration for it.\n        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n        // has already been marked as unsupported. We can just return without doing anything.\n        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n        if (!markets[asset].isSupported) {\n            return uint(Error.NO_ERROR);\n        }\n\n        // If we get here, we know market is configured and is supported, so set isSupported to false\n        markets[asset].isSupported = false;\n\n        emit SuspendedMarket(asset);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n     * @dev Owner function to set the risk parameters\n     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be \u003c= 0.1 and must be less than (descaled collateral ratio minus 1)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n        }\n\n        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n\n        Error err;\n        Exp memory newLiquidationDiscountPlusOne;\n\n        // Make sure new collateral ratio value is not below minimum value\n        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n        // C \u003c L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n\n        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n        }\n\n        // Save current values so we can emit them in log.\n        Exp memory oldCollateralRatio = collateralRatio;\n        Exp memory oldLiquidationDiscount = liquidationDiscount;\n\n        // Store new values\n        collateralRatio = newCollateralRatio;\n        liquidationDiscount = newLiquidationDiscount;\n\n        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the origination fee (which is a multiplier on new borrows)\n     * @dev Owner function to set the origination fee\n     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be \u003e= 1.1\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n        }\n\n        // Save current value so we can emit it in log.\n        Exp memory oldOriginationFee = originationFee;\n\n        originationFee = Exp({mantissa: originationFeeMantissa});\n\n        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Sets the interest rate model for a given market\n     * @dev Admin function to set interest rate model\n     * @param asset Asset to support\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n        }\n\n        // Set the interest rate model to `modelAddress`\n        markets[asset].interestRateModel = interestRateModel;\n\n        emit SetMarketInterestRateModel(asset, interestRateModel);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` \u003c= equity. Equity= cash - (supply + borrows)\n     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount \u003c= cash - (supply + borrows)\n     * @param asset asset whose equity should be withdrawn\n     * @param amount amount of equity to withdraw; must not exceed equity available\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n        }\n\n        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n        uint cash = getCash(asset);\n        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n        if (err0 != Error.NO_ERROR) {\n            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n        }\n\n        if (amount \u003e equity) {\n            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset out of the protocol to the admin\n            Error err2 = doTransferOut(asset, admin, amount);\n            if (err2 != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n        emit EquityWithdrawn(asset, equity, amount, admin);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Set WETH token contract address\n     * @param wethContractAddress Enter the WETH token address\n     */\n    function setWethAddress(address wethContractAddress) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n        }\n        wethAddress = wethContractAddress;\n        WETHContract = AlkemiWETH(wethAddress);\n        emit WETHAddressSet(wethContractAddress);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n     * @return errors if any\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n        user; // To silence the warning of unused local variable\n        if(wethAddress != address(0)){\n            WETHContract.deposit.value(etherAmount)();\n            return uint(Error.NO_ERROR);\n        }\n        else {\n            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n        }\n    }\n\n    /**\n     * @dev Revert Ether paid by user back to user\u0027s account in case transaction fails due to some other reason\n     * @param etherAmount Amount of ether to be sent back to user\n     * @param user User account address\n     */\n    function revertEtherToUser(address user, uint etherAmount) internal {\n        if(etherAmount \u003e 0){\n            user.transfer(etherAmount);\n        }\n    }\n\n    /**\n     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n     * @dev add amount of supported asset to msg.sender\u0027s account\n     * @param asset The market asset to supply\n     * @param amount The amount to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function supply(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage balance = supplyBalances[msg.sender][asset];\n\n        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n        }\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // Fail gracefully if asset is not approved or has insufficient balance\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,msg.value);\n                if(supplyError !=0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                }\n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n        balance.principal = localResults.userSupplyUpdated;\n        balance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice withdraw `amount` of `ether` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `ether` from msg.sender\u0027s account to msg.sender\n     * @param etherAmount Amount of ether to be converted to WETH\n     * @param user User account address\n     */\n    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n            WETHContract.withdraw(user,etherAmount);\n            return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice send Ether from contract to a user\n     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n     */\n    function sendEtherToUser(address user, uint amount) public returns (uint) {\n        // Check caller = admin\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n        }\n        user.transfer(amount);\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice withdraw `amount` of `asset` from sender\u0027s account to sender\u0027s address\n     * @dev withdraw `amount` of `asset` from msg.sender\u0027s account to msg.sender\n     * @param asset The market asset to withdraw\n     * @param requestedAmount The amount to withdraw (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function withdraw(address asset, uint requestedAmount) public returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n        }\n\n        Market storage market = markets[asset];\n        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n\n        WithdrawLocalVars memory localResults; // Holds all our calculation results\n        Error err; // Re-used for every function call that includes an Error in its return value(s).\n        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n\n        // We calculate the user\u0027s accountLiquidity and accountShortfall.\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // We calculate the newSupplyIndex, user\u0027s supplyCurrent and supplyUpdated for the asset\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // If the user specifies -1 amount to withdraw (\"max\"),  withdrawAmount =\u003e the lesser of withdrawCapacity and supplyCurrent\n        if (requestedAmount == uint(-1)) {\n            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n            }\n            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n        } else {\n            localResults.withdrawAmount = requestedAmount;\n        }\n\n        // From here on we should NOT use requestedAmount.\n\n        // Fail gracefully if protocol has insufficient cash\n        // If protocol has insufficient cash, the sub operation will underflow.\n        localResults.currentCash = getCash(asset);\n        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n        }\n\n        // We check that the amount is less than or equal to supplyCurrent\n        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n        if (err != Error.NO_ERROR) {\n            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // We want to know the user\u0027s withdrawCapacity, denominated in the asset\n        // Customer\u0027s withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n\n        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply.\n        // Note that, even though the customer is withdrawing, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        // We calculate the newBorrowIndex\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // failure\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalSupply =  localResults.newTotalSupply;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n        supplyBalance.principal = localResults.userSupplyUpdated;\n        supplyBalance.interestIndex = localResults.newSupplyIndex;\n\n        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n        \n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev Gets the user\u0027s account liquidity and account shortfall balances. This includes\n     *      any accumulated interest thus far but does NOT actually update anything in\n     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n     */\n    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n        Error err;\n        uint sumSupplyValuesMantissa;\n        uint sumBorrowValuesMantissa;\n        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        Exp memory result;\n\n        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n\n        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n        if (err != Error.NO_ERROR) {\n            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n        }\n\n        // if sumSupplies \u003c sumBorrows, then the user is under collateralized and has account shortfall.\n        // else the user meets the collateral ratio and has account liquidity.\n        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n            // accountShortfall = borrows - supplies\n            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n        } else {\n            // accountLiquidity = supplies - borrows\n            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n\n            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n        }\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n     * TODO: To help save gas we could think about using the current Market.interestIndex\n     *       accumulate interest rather than calculating it\n     */\n    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n\n        /** By definition, all collateralMarkets are those that contribute to the user\u0027s\n         * liquidity and shortfall so we need only loop through those markets.\n         * To handle avoiding intermediate negative results, we will sum all the user\u0027s\n         * supply balances and borrow balances (with collateral ratio) separately and then\n         * subtract the sums at the end.\n         */\n\n        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n        localResults.sumSupplies = Exp({mantissa: 0});\n        localResults.sumBorrows = Exp({mantissa: 0});\n        Error err; // Re-used for all intermediate errors\n        localResults.collateralMarketsLength = collateralMarkets.length;\n\n        for (uint i = 0; i \u003c localResults.collateralMarketsLength; i++) {\n            localResults.assetAddress = collateralMarkets[i];\n            Market storage currentMarket = markets[localResults.assetAddress];\n            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n\n            if (supplyBalance.principal \u003e 0) {\n                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\n                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // We have the user\u0027s supply balance with interest so let\u0027s multiply by the asset price to get the total value\n                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of supplies\n                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n\n            if (borrowBalance.principal \u003e 0) {\n                // We perform a similar actions to get the user\u0027s borrow balance\n                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // In the case of borrow, we multiply the borrow value by the collateral ratio\n                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n\n                // Add this to our running sum of borrows\n                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n                if (err != Error.NO_ERROR) {\n                    return (err, 0, 0);\n                }\n            }\n        }\n\n        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n    }\n\n    /**\n     * @notice Gets the ETH values of the user\u0027s accumulated supply and borrow balances, scaled by 10e18.\n     *         This includes any accumulated interest thus far but does NOT actually update anything in\n     *         storage\n     * @dev Gets ETH values of accumulated supply and borrow balances\n     * @param userAddress account for which to sum values\n     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n     *          sum ETH value of supplies scaled by 10e18,\n     *          sum ETH value of borrows scaled by 10e18)\n     */\n    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n        if (err != Error.NO_ERROR) {\n\n            return (uint(err), 0, 0);\n        }\n\n        return (0, supplyValue, borrowValue);\n    }\n\n    /**\n     * @notice Users repay borrowed assets from their own address to the protocol.\n     * @param asset The market asset to repay\n     * @param amount The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(address asset, uint amount) public payable returns (uint) {\n        if (paused) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n        }\n        PayBorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n        Error err;\n        uint rateCalculationResultCode;\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        uint reimburseAmount;\n        // If the user specifies -1 amount to repay (“max”), repayAmount =\u003e\n        // the lesser of the senders ERC-20 balance and borrowCurrent\n        if (asset != wethAddress) {\n            if (amount == uint(-1)) {\n                localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n            } else {\n                localResults.repayAmount = amount;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (amount \u003e localResults.userBorrowCurrent) {\n                localResults.repayAmount = localResults.userBorrowCurrent;\n                (err, reimburseAmount) = sub(amount,localResults.userBorrowCurrent); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.repayAmount = amount;\n            }\n        }\n\n        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n        // Note: this checks that repayAmount is less than borrowCurrent\n        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Fail gracefully if asset is not approved or has insufficient balance\n        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            revertEtherToUser(msg.sender,msg.value);\n            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the customer is paying some of their borrow, if they\u0027ve accumulated a lot of interest since their last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from user\n        localResults.currentCash = getCash(asset);\n\n        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            revertEtherToUser(msg.sender,msg.value);\n            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            revertEtherToUser(msg.sender,msg.value);\n            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n        if(asset != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            revertEtherToUser(msg.sender,msg.value);\n            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n            }\n        } else {\n            if (msg.value == amount){\n                uint supplyError = supplyEther(msg.sender,localResults.repayAmount);\n                //Repay excess funds\n                if(reimburseAmount \u003e 0){\n                    revertEtherToUser(msg.sender,reimburseAmount);\n                }\n                if(supplyError != 0 ){\n                    revertEtherToUser(msg.sender,msg.value);\n                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n                } \n            }\n            else {\n                revertEtherToUser(msg.sender,msg.value);\n                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n        \n        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n\n        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @notice users repay all or some of an underwater borrow and receive collateral\n     * @param targetAccount The account whose borrow should be liquidated\n     * @param assetBorrow The market asset to repay\n     * @param assetCollateral The borrower\u0027s market asset to receive in exchange\n     * @param requestedAmountClose The amount to repay (or -1 for max)\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) payable public isLiquidator returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n        }\n        LiquidateLocalVars memory localResults;\n        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n        // We\u0027ll use localResults.liquidator inside this function for clarity vs using msg.sender.\n        localResults.targetAccount = targetAccount;\n        localResults.assetBorrow = assetBorrow;\n        localResults.liquidator = msg.sender;\n        localResults.assetCollateral = assetCollateral;\n\n        Market storage borrowMarket = markets[assetBorrow];\n        Market storage collateralMarket = markets[assetCollateral];\n        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n\n        // Liquidator might already hold some of the collateral asset\n        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n\n        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n        Error err; // re-used for all intermediate errors\n\n        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n        if(err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n        }\n\n        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n        assert(err == Error.NO_ERROR);\n\n        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Liquidator may or may not already have some collateral asset.\n        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We update the protocol\u0027s totalSupply for assetCollateral in 2 steps, first by adding target user\u0027s accumulated\n        // interest and then by adding the liquidator\u0027s accumulated interest.\n\n        // Step 1 of 2: We add the target user\u0027s supplyCurrent and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the target user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n        }\n\n        // Step 2 of 2: We add the liquidator\u0027s supplyCurrent of collateral asset and subtract their checkpointedBalance\n        // (which has the desired effect of adding accrued interest from the calling user)\n        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n        }\n\n        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n        // This is equal to the lesser of\n        // 1. borrowCurrent; (already calculated)\n        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n        // discountedRepayToEvenAmount=\n        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n        // 3. discountedBorrowDenominatedCollateral\n        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n\n        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n        (err, localResults.discountedBorrowDenominatedCollateral) =\n        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n        }\n\n        if (borrowMarket.isSupported) {\n            // Market is supported, so we calculate item 2 from above.\n            (err, localResults.discountedRepayToEvenAmount) =\n            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n            }\n\n            // We need to do a two-step min to select from all 3 values\n            // min1\u00263 = min(item 1, item 3)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n\n            // min1\u00263\u00262 = min(min1\u00263, 2)\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n        } else {\n            // Market is not supported, so we don\u0027t need to calculate item 2.\n            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n        }\n\n        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (assetBorrow != wethAddress) {\n            if (requestedAmountClose == uint(-1)) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        } else {\n            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n            if (requestedAmountClose \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n                (err, localResults.reimburseAmount) = sub(requestedAmountClose,localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset); // reimbursement called at the end to make sure function does not have any other errors\n                if (err != Error.NO_ERROR) {\n                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n                }\n            } else {\n                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n            }\n        }\n\n        // From here on, no more use of `requestedAmountClose`\n\n        // Verify closeBorrowAmount_TargetUnderwaterAsset \u003c= maxCloseableBorrowAmount_TargetUnderwaterAsset\n        if (localResults.closeBorrowAmount_TargetUnderwaterAsset \u003e localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n        }\n\n        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n        }\n\n        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n        // Fail gracefully if asset is not approved or has insufficient balance\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n            }\n        }\n\n        // We are going to repay the target user\u0027s borrow using the calling user\u0027s funds\n        // We update the protocol\u0027s totalBorrow for assetBorrow, by subtracting the target user\u0027s prior checkpointed balance,\n        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n\n        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset \u003c= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can\u0027t underflow\n        assert(err == Error.NO_ERROR);\n\n        // We calculate the protocol\u0027s totalBorrow for assetBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow\n        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n        // action, the updated balance *could* be higher than the prior checkpointed balance.\n        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // We need to calculate what the updated cash will be after we transfer in from liquidator\n        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n        // (Please note that we don\u0027t need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n\n        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don\u0027t recalculate it.\n        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n        }\n\n        // Now we look at collateral. We calculated target user\u0027s accumulated supply balance and the supply index above.\n        // Now we need to calculate the borrow index.\n        // We don\u0027t need to calculate new rates for the collateral asset because we have not changed utilization:\n        //  - accumulating interest on the target user\u0027s collateral does not change cash or borrows\n        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n        }\n\n        // We checkpoint the target user\u0027s assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // The sub won\u0027t underflow because because seizeSupplyAmount_TargetCollateralAsset \u003c= target user\u0027s collateral balance\n        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n        assert (err == Error.NO_ERROR);\n\n        // We checkpoint the liquidating user\u0027s assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n        // We can\u0027t overflow here because if this would overflow, then we would have already overflowed above and failed\n        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n        assert (err == Error.NO_ERROR);\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n        if(assetBorrow != wethAddress) { // WETH is supplied to MoneyMarket contract in case of ETH automatically\n            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n            }\n        } else {\n            uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n            //Repay excess funds\n                if(localResults.reimburseAmount \u003e 0){\n                    revertEtherToUser(localResults.liquidator,localResults.reimburseAmount);\n                }\n            if(supplyError !=0 ){\n                return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n            }\n        }\n\n        // Save borrow market updates\n        borrowMarket.blockNumber = getBlockNumber();\n        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n        // borrowMarket.totalSupply does not need to be updated\n        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        // Save collateral market updates\n        // We didn\u0027t calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n        collateralMarket.blockNumber = getBlockNumber();\n        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n\n        // Save user updates\n\n        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n\n        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n\n        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n        \n        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n\n        emitLiquidationEvent(localResults);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    /**\n     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n     */\n    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n        emit BorrowLiquidated(localResults.targetAccount,\n            localResults.assetBorrow,\n            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n            localResults.liquidator,\n            localResults.assetCollateral,\n            localResults.startingSupplyBalance_TargetCollateralAsset,\n            localResults.currentSupplyBalance_TargetCollateralAsset,\n            localResults.seizeSupplyAmount_TargetCollateralAsset,\n            localResults.updatedSupplyBalance_TargetCollateralAsset);\n    }\n\n    /**\n     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n     *      If the market isn\u0027t supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n     */\n    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n        Error err;\n        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n        Exp memory accountShortfall_TargetUser;\n        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n        Exp memory discountedPrice_UnderwaterAsset;\n        Exp memory rawResult;\n\n        // we calculate the target user\u0027s shortfall, denominated in Ether, that the user is below the collateral ratio\n        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n        // discountedCollateralRatioMinusOne \u003c collateralRatio\n        // so if underwaterAssetPrice * collateralRatio did not overflow then\n        // underwaterAssetPrice * discountedCollateralRatioMinusOne can\u0027t overflow either\n        assert(err == Error.NO_ERROR);\n\n        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n        // It\u0027s theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n    /**\n     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n     */\n    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n        Error err;\n        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n        Exp memory rawResult;\n\n        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n     */\n    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n\n        // re-used for all intermediate errors\n        Error err;\n\n        // (1+liquidationDiscount)\n        Exp memory liquidationMultiplier;\n\n        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n\n        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n        // or, expanded:\n        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n        Exp memory finalNumerator;\n\n        // finalNumerator / priceCollateral\n        Exp memory rawResult;\n\n        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n        // liquidation discount will be enforced \u003c 1, so 1 + liquidationDiscount can\u0027t overflow.\n        assert(err == Error.NO_ERROR);\n\n        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n        if (err != Error.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (Error.NO_ERROR, truncate(rawResult));\n    }\n\n\n    /**\n     * @notice Users borrow assets from the protocol to their own address\n     * @param asset The market asset to borrow\n     * @param amount The amount to borrow\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function borrow(address asset, uint amount) public isKYCVerifiedCustomer returns (uint) {\n        if (paused) {\n            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n        }\n        BorrowLocalVars memory localResults;\n        Market storage market = markets[asset];\n        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n\n        Error err;\n        uint rateCalculationResultCode;\n\n        // Fail if market not supported\n        if (!market.isSupported) {\n            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n        }\n\n        // We calculate the newBorrowIndex, user\u0027s borrowCurrent and borrowUpdated for the asset\n        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n        }\n\n        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n        }\n\n        // Calculate origination fee.\n        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n        }\n        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n\n        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n        }\n\n        // We calculate the protocol\u0027s totalBorrow by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated borrow with fee\n        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n        }\n\n        // Check customer liquidity\n        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n        }\n\n        // Fail if customer already has a shortfall\n        if (!isZeroExp(localResults.accountShortfall)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n        }\n\n        // Would the customer have a shortfall after this borrow (including origination fee)?\n        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] \u003e accountLiquidity`\n        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n        }\n        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n        }\n\n        // Fail gracefully if protocol has insufficient cash\n        localResults.currentCash = getCash(asset);\n        // We need to calculate what the updated cash will be after we transfer out to the user\n        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n        if (err != Error.NO_ERROR) {\n            // Note: we ignore error here and call this token insufficient cash\n            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n        }\n\n        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n\n        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n        if (err != Error.NO_ERROR) {\n            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n        }\n\n        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n        if (rateCalculationResultCode != 0) {\n            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n        }\n\n        /////////////////////////\n        // EFFECTS \u0026 INTERACTIONS\n        // (No safe failures beyond this point)\n\n        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n            err = doTransferOut(asset, msg.sender, amount);\n            if (err != Error.NO_ERROR) {\n                // This is safe since it\u0027s our first interaction and it didn\u0027t do anything if it failed\n                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n            }\n        } else {\n            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n            if(withdrawalerr != 0){\n                return uint(withdrawalerr); // success\n            }\n        }\n\n        // Save market updates\n        market.blockNumber = getBlockNumber();\n        market.totalBorrows =  localResults.newTotalBorrows;\n        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n        market.supplyIndex = localResults.newSupplyIndex;\n        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n        market.borrowIndex = localResults.newBorrowIndex;\n\n        // Save user updates\n        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n        borrowBalance.principal = localResults.userBorrowUpdated;\n        borrowBalance.interestIndex = localResults.newBorrowIndex;\n\n        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n\n        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n\n        return uint(Error.NO_ERROR); // success\n    }\n\n    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n        uint originationFeeRepaid = 0;\n        if (originationFeeBalance[user][asset] != 0){\n            if (amount \u003c originationFeeBalance[user][asset]) {\n                originationFeeRepaid = amount;\n            } else {\n                originationFeeRepaid = originationFeeBalance[user][asset];\n            }\n            Balance storage balance = supplyBalances[admin][asset];\n\n            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n            Error err; // Re-used for every function call that includes an Error in its return value(s).\n\n            originationFeeBalance[user][asset] -= originationFeeRepaid;\n\n            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n\n            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n\n            // We calculate the protocol\u0027s totalSupply by subtracting the user\u0027s prior checkpointed balance, adding user\u0027s updated supply\n            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n\n            // Save market updates\n            markets[asset].totalSupply =  localResults.newTotalSupply;\n\n            // Save user updates\n            localResults.startingBalance = balance.principal;\n            balance.principal = localResults.userSupplyUpdated;\n            balance.interestIndex = newSupplyIndex;\n\n            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n        }\n    }\n}"},"PriceOracle.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Exponential.sol\";\n\ncontract ExchangeRateModel {\n    function scale() external view returns (uint);\n    function getExchangeRate() external view returns (uint);\n    function getMaxSwingRate(uint interval) external view returns (uint);\n    function getFixedInterestRate(uint interval) external view returns (uint);\n    function getFixedExchangeRate(uint interval) public view returns (uint);\n}\n\ncontract PriceOracle is Exponential {\n\n    /**\n     * @dev flag for whether or not contract is paused\n     *\n     */\n    bool public paused;\n\n    uint public constant numBlocksPerPeriod = 240; // approximately 1 hour: 60 seconds/minute * 60 minutes/hour * 1 block/15 seconds\n\n    uint public constant maxSwingMantissa = (10 ** 17); // 0.1\n\n    /**\n     * @dev Mapping of asset addresses to exchange rate information. Dynamic changes in asset prices based on exchange rates.\n     *\n     * map: assetAddress -\u003e ExchangeRateInfo\n     */\n    struct ExchangeRateInfo {\n        address exchangeRateModel;\n        uint exchangeRate;\n        uint maxSwingRate;\n        uint maxSwingDuration;\n    }\n    mapping(address =\u003e ExchangeRateInfo) public exchangeRates;\n\n    /**\n     * @dev Mapping of asset addresses and their corresponding price in terms of Eth-Wei\n     *      which is simply equal to AssetWeiPrice * 10e18. For instance, if OMG token was\n     *      worth 5x Eth then the price for OMG would be 5*10e18 or Exp({mantissa: 5000000000000000000}).\n     * map: assetAddress -\u003e Exp\n     */\n    mapping(address =\u003e Exp) public _assetPrices;\n\n    constructor(address _poster) public {\n        anchorAdmin = msg.sender;\n        poster = _poster;\n        maxSwing = Exp({mantissa : maxSwingMantissa});\n    }\n\n    /**\n     * @notice Do not pay into PriceOracle\n     */\n    function() payable public {\n        revert();\n    }\n\n    enum OracleError {\n        NO_ERROR,\n        UNAUTHORIZED,\n        FAILED_TO_SET_PRICE\n    }\n\n    enum OracleFailureInfo {\n        ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK,\n        SET_PAUSED_OWNER_CHECK,\n        SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK,\n        SET_PENDING_ANCHOR_PERMISSION_CHECK,\n        SET_PRICE_CALCULATE_SWING,\n        SET_PRICE_CAP_TO_MAX,\n        SET_PRICE_MAX_SWING_CHECK,\n        SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO,\n        SET_PRICE_PERMISSION_CHECK,\n        SET_PRICE_ZERO_PRICE,\n        SET_PRICES_PARAM_VALIDATION,\n        SET_PRICE_IS_READER_ASSET\n    }\n\n    /**\n     * @dev `msgSender` is msg.sender; `error` corresponds to enum OracleError; `info` corresponds to enum OracleFailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     */\n    event OracleFailure(address msgSender, address asset, uint error, uint info, uint detail);\n\n    /**\n     * @dev use this when reporting a known error from the price oracle or a non-upgradeable collaborator\n     *      Using Oracle in name because we already inherit a `fail` function from ErrorReporter.sol via Exponential.sol\n     */\n    function failOracle(address asset, OracleError err, OracleFailureInfo info) internal returns (uint) {\n        emit OracleFailure(msg.sender, asset, uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev Use this when reporting an error from the money market. Give the money market result as `details`\n     */\n    function failOracleWithDetails(address asset, OracleError err, OracleFailureInfo info, uint details) internal returns (uint) {\n        emit OracleFailure(msg.sender, asset, uint(err), uint(info), details);\n\n        return uint(err);\n    }\n\n    /**\n     * @dev An administrator who can set the pending anchor value for assets.\n     *      Set in the constructor.\n     */\n    address public anchorAdmin;\n\n    /**\n     * @dev pending anchor administrator for this contract.\n     */\n    address public pendingAnchorAdmin;\n\n    /**\n     * @dev Address of the price poster.\n     *      Set in the constructor.\n     */\n    address public poster;\n\n    /**\n     * @dev maxSwing the maximum allowed percentage difference between a new price and the anchor\u0027s price\n     *      Set only in the constructor\n     */\n    Exp public maxSwing;\n\n    struct Anchor {\n        // floor(block.number / numBlocksPerPeriod) + 1\n        uint period;\n\n        // Price in ETH, scaled by 10**18\n        uint priceMantissa;\n    }\n\n    /**\n     * @dev anchors by asset\n     */\n    mapping(address =\u003e Anchor) public anchors;\n\n    /**\n     * @dev pending anchor prices by asset\n     */\n    mapping(address =\u003e uint) public pendingAnchors;\n\n    /**\n     * @dev emitted when a pending anchor is set\n     * @param asset Asset for which to set a pending anchor\n     * @param oldScaledPrice if an unused pending anchor was present, its value; otherwise 0.\n     * @param newScaledPrice the new scaled pending anchor price\n     */\n    event NewPendingAnchor(address anchorAdmin, address asset, uint oldScaledPrice, uint newScaledPrice);\n\n    /**\n     * @notice provides ability to override the anchor price for an asset\n     * @dev Admin function to set the anchor price for an asset\n     * @param asset Asset for which to override the anchor price\n     * @param newScaledPrice New anchor price\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n     */\n    function _setPendingAnchor(address asset, uint newScaledPrice) public returns (uint) {\n        // Check caller = anchorAdmin. Note: Deliberately not allowing admin. They can just change anchorAdmin if desired.\n        if (msg.sender != anchorAdmin) {\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_PERMISSION_CHECK);\n        }\n\n        uint oldScaledPrice = pendingAnchors[asset];\n        pendingAnchors[asset] = newScaledPrice;\n\n        emit NewPendingAnchor(msg.sender, asset, oldScaledPrice, newScaledPrice);\n\n        return uint(OracleError.NO_ERROR);\n    }\n\n    /**\n     * @dev emitted for all exchangeRates changes\n     */\n    event SetExchangeRate(address asset, address exchangeRateModel, uint exchangeRate, uint maxSwingRate, uint maxSwingDuration);\n    event SetMaxSwingRate(address asset, uint oldMaxSwingRate, uint newMaxSwingRate, uint maxSwingDuration);\n\n    /**\n     * @dev emitted for all price changes\n     */\n    event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n    /**\n     * @dev emitted if this contract successfully posts a capped-to-max price to the money market\n     */\n    event CappedPricePosted(address asset, uint requestedPriceMantissa, uint anchorPriceMantissa, uint cappedPriceMantissa);\n\n    /**\n     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n     */\n    event SetPaused(bool newState);\n\n    /**\n     * @dev emitted when pendingAnchorAdmin is changed\n     */\n    event NewPendingAnchorAdmin(address oldPendingAnchorAdmin, address newPendingAnchorAdmin);\n\n    /**\n     * @dev emitted when pendingAnchorAdmin is accepted, which means anchor admin is updated\n     */\n    event NewAnchorAdmin(address oldAnchorAdmin, address newAnchorAdmin);\n\n    /**\n     * @dev emitted when poster is changed\n     */\n    event NewPoster(address oldPoster, address newPoster);\n\n    /**\n     * @notice set `paused` to the specified state\n     * @dev Admin function to pause or resume the market\n     * @param requestedState value to assign to `paused`\n     * @return uint 0=success, otherwise a failure\n     */\n    function _setPaused(bool requestedState) public returns (uint) {\n        // Check caller = anchorAdmin\n        if (msg.sender != anchorAdmin) {\n            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PAUSED_OWNER_CHECK);\n        }\n\n        paused = requestedState;\n        emit SetPaused(requestedState);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Begins transfer of anchor admin rights. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\n     * @dev Admin function to begin change of anchor admin. The newPendingAnchorAdmin must call `_acceptAnchorAdmin` to finalize the transfer.\n     * @param newPendingAnchorAdmin New pending anchor admin.\n     * @return uint 0=success, otherwise a failure\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\n     */\n    function _setPendingAnchorAdmin(address newPendingAnchorAdmin) public returns (uint) {\n        // Check caller = anchorAdmin\n        if (msg.sender != anchorAdmin) {\n            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPendingAnchorAdmin = pendingAnchorAdmin;\n        // Store pendingAdmin = newPendingAdmin\n        pendingAnchorAdmin = newPendingAnchorAdmin;\n\n        emit NewPendingAnchorAdmin(oldPendingAnchorAdmin, newPendingAnchorAdmin);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Accepts transfer of anchor admin rights. msg.sender must be pendingAnchorAdmin\n     * @dev Admin function for pending anchor admin to accept role and update anchor admin\n     * @return uint 0=success, otherwise a failure\n     */\n    function _acceptAnchorAdmin() public returns (uint) {\n        // Check caller = pendingAnchorAdmin\n        // msg.sender can\u0027t be zero\n        if (msg.sender != pendingAnchorAdmin) {\n            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.ACCEPT_ANCHOR_ADMIN_PENDING_ANCHOR_ADMIN_CHECK);\n        }\n\n        // Save current value for inclusion in log\n        address oldAnchorAdmin = anchorAdmin;\n        // Store admin = pendingAnchorAdmin\n        anchorAdmin = pendingAnchorAdmin;\n        // Clear the pending value\n        pendingAnchorAdmin = 0;\n\n        emit NewAnchorAdmin(oldAnchorAdmin, msg.sender);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice Set new poster.\n     * @dev Admin function to change of poster.\n     * @param newPoster New poster.\n     * @return uint 0=success, otherwise a failure\n     *\n     * TODO: Should we add a second arg to verify, like a checksum of `newAnchorAdmin` address?\n     */\n    function _setPoster(address newPoster) public returns (uint) {\n        assert(poster != newPoster);\n        // Check caller = anchorAdmin\n        if (msg.sender != anchorAdmin) {\n            return failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PENDING_ANCHOR_ADMIN_OWNER_CHECK);\n        }\n\n        // save current value, if any, for inclusion in log\n        address oldPoster = poster;\n        // Store poster = newPoster\n        poster = newPoster;\n\n        emit NewPoster(oldPoster, newPoster);\n\n        return uint(Error.NO_ERROR);\n    }\n\n    /**\n     * @notice set new exchange rate model\n     * @dev function to set exchangeRateModel for an asset\n     * @param asset asset for which to set the exchangeRateModel\n     * @param exchangeRateModel exchangeRateModel address, if the exchangeRateModel is address(0), cancel the exchangeRates\n     * @param maxSwingDuration maxSwingDuration uint, Is a value greater than zero and less than a second of a week\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n     */\n    function setExchangeRate(address asset, address exchangeRateModel, uint maxSwingDuration) public returns (uint) {\n\n        // Fail when msg.sender is not poster\n        if (msg.sender != anchorAdmin) {\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n        }\n\n        require(exchangeRateModel != address(0), \"setExchangeRate: exchangeRateModel cannot be a zero address.\");\n        require(\n            maxSwingDuration \u003e 0 \u0026\u0026 maxSwingDuration \u003c= 604800,\n            \"setExchangeRate: maxSwingDuration cannot be zero, less than 31536000 (seconds per week).\"\n        );\n\n        uint currentExchangeRate = ExchangeRateModel(exchangeRateModel).getExchangeRate();\n        require(currentExchangeRate \u003e 0, \"setExchangeRate: currentExchangeRate not zero.\");\n\n        uint maxSwingRate = ExchangeRateModel(exchangeRateModel).getMaxSwingRate(maxSwingDuration);\n        require(\n            maxSwingRate \u003e 0 \u0026\u0026 maxSwingRate \u003c= ExchangeRateModel(exchangeRateModel).getMaxSwingRate(604800),\n            \"setExchangeRate: maxSwingRate cannot be zero, less than 31536000 (seconds per week).\"\n        );\n\n        exchangeRates[asset].exchangeRateModel = exchangeRateModel;\n        exchangeRates[asset].exchangeRate = currentExchangeRate;\n        exchangeRates[asset].maxSwingRate = maxSwingRate;\n        exchangeRates[asset].maxSwingDuration = maxSwingDuration;\n\n        emit SetExchangeRate(asset, exchangeRateModel, currentExchangeRate, maxSwingRate, maxSwingDuration);\n        return uint(OracleError.NO_ERROR);\n    }\n\n    /**\n     * @notice set new exchange rate maxSwingRate\n     * @dev function to set exchange rate maxSwingRate for an asset\n     * @param asset asset for which to set the exchange rate maxSwingRate\n     * @param maxSwingDuration Interval time\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n     */\n    function setMaxSwingRate(address asset, uint maxSwingDuration) public returns (uint) {\n\n        // Fail when msg.sender is not poster\n        if (msg.sender != anchorAdmin) {\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n        }\n\n        require(\n            maxSwingDuration \u003e 0 \u0026\u0026 maxSwingDuration \u003c= 604800,\n            \"setMaxSwingRate: maxSwingDuration cannot be zero, less than 31536000 (seconds per week).\"\n        );\n\n        ExchangeRateModel exchangeRateModel = ExchangeRateModel(exchangeRates[asset].exchangeRateModel);\n        uint newMaxSwingRate = exchangeRateModel.getMaxSwingRate(maxSwingDuration);\n        uint oldMaxSwingRate = exchangeRates[asset].maxSwingRate;\n        require(oldMaxSwingRate != newMaxSwingRate, \"setMaxSwingRate: Old and new values cannot be the same.\");\n        require(\n            newMaxSwingRate \u003e 0 \u0026\u0026 newMaxSwingRate \u003c= exchangeRateModel.getMaxSwingRate(604800),\n            \"setMaxSwingRate: maxSwingRate cannot be zero, less than 31536000 (seconds per week).\"\n        );\n\n        exchangeRates[asset].maxSwingRate = newMaxSwingRate;\n        exchangeRates[asset].maxSwingDuration = maxSwingDuration;\n\n        emit SetMaxSwingRate(asset, oldMaxSwingRate, newMaxSwingRate, maxSwingDuration);\n        return uint(OracleError.NO_ERROR);\n    }\n\n    /**\n     * @notice retrieves price of an asset\n     * @dev function to get price for an asset\n     * @param asset Asset for which to get the price\n     * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\n     */\n    function assetPrices(address asset) public view returns (uint) {\n        // Note: zero is treated by the money market as an invalid\n        //       price and will cease operations with that asset\n        //       when zero.\n        //\n        // We get the price as:\n        //\n        //  1. If the contract is paused, return 0.\n        //  2. If the asset has an exchange rate model, the asset price is calculated based on the exchange rate.\n        //  3. Return price in `_assetPrices`, which may be zero.\n\n        if (paused) {\n            return 0;\n        } else {\n            ExchangeRateInfo memory exchangeRateInfo = exchangeRates[asset];\n            if (exchangeRateInfo.exchangeRateModel != address(0)) {\n                uint scale = ExchangeRateModel(exchangeRateInfo.exchangeRateModel).scale();\n                uint currentExchangeRate = ExchangeRateModel(exchangeRateInfo.exchangeRateModel).getExchangeRate();\n                uint currentChangeRate;\n                Error err;\n                (err, currentChangeRate) = mul(currentExchangeRate, scale);\n                if (err != Error.NO_ERROR)\n                    return 0;\n\n                currentChangeRate = currentChangeRate / exchangeRateInfo.exchangeRate;\n                // require(currentExchangeRate \u003e= exchangeRateInfo.exchangeRate \u0026\u0026 currentChangeRate \u003c= exchangeRateInfo.maxSwingRate, \"assetPrices: Abnormal exchange rate.\");\n                if (currentExchangeRate \u003c exchangeRateInfo.exchangeRate || currentChangeRate \u003e exchangeRateInfo.maxSwingRate)\n                    return 0;\n\n                uint price;\n                (err, price) = mul(_assetPrices[asset].mantissa, currentExchangeRate);\n                if (err != Error.NO_ERROR)\n                    return 0;\n\n                return price / scale;\n            } else {\n                return _assetPrices[asset].mantissa;\n            }\n        }\n    }\n\n    /**\n     * @notice retrieves price of an asset\n     * @dev function to get price for an asset\n     * @param asset Asset for which to get the price\n     * @return uint mantissa of asset price (scaled by 1e18) or zero if unset or contract paused\n     */\n    function getPrice(address asset) public view returns (uint) {\n        return assetPrices(asset);\n    }\n\n    struct SetPriceLocalVars {\n        Exp price;\n        Exp swing;\n        Exp anchorPrice;\n        uint anchorPeriod;\n        uint currentPeriod;\n        bool priceCapped;\n        uint cappingAnchorPriceMantissa;\n        uint pendingAnchorMantissa;\n    }\n\n    /**\n     * @notice entry point for updating prices\n     * @dev function to set price for an asset\n     * @param asset Asset for which to set the price\n     * @param requestedPriceMantissa requested new price, scaled by 10**18\n     * @return uint 0=success, otherwise a failure (see enum OracleError for details)\n     */\n    function setPrice(address asset, uint requestedPriceMantissa) public returns (uint) {\n        // Fail when msg.sender is not poster\n        if (msg.sender != poster) {\n            return failOracle(asset, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n        }\n\n        return setPriceInternal(asset, requestedPriceMantissa);\n    }\n\n    function setPriceInternal(address asset, uint requestedPriceMantissa) internal returns (uint) {\n        // re-used for intermediate errors\n        Error err;\n        SetPriceLocalVars memory localVars;\n        // We add 1 for currentPeriod so that it can never be zero and there\u0027s no ambiguity about an unset value.\n        // (It can be a problem in tests with low block numbers.)\n        localVars.currentPeriod = (block.number / numBlocksPerPeriod) + 1;\n        localVars.pendingAnchorMantissa = pendingAnchors[asset];\n        localVars.price = Exp({mantissa : requestedPriceMantissa});\n\n        if (exchangeRates[asset].exchangeRateModel != address(0)) {\n\n            uint currentExchangeRate = ExchangeRateModel(exchangeRates[asset].exchangeRateModel).getExchangeRate();\n            uint scale = ExchangeRateModel(exchangeRates[asset].exchangeRateModel).scale();\n            uint currentChangeRate;\n            (err, currentChangeRate) = mul(currentExchangeRate, scale);\n            assert(err == Error.NO_ERROR);\n\n            currentChangeRate = currentChangeRate / exchangeRates[asset].exchangeRate;\n            require(currentExchangeRate \u003e= exchangeRates[asset].exchangeRate \u0026\u0026 currentChangeRate \u003c= exchangeRates[asset].maxSwingRate, \"setPriceInternal: Abnormal exchange rate.\");\n            exchangeRates[asset].exchangeRate = currentExchangeRate;\n        }\n\n        if (localVars.pendingAnchorMantissa != 0) {\n            // let\u0027s explicitly set to 0 rather than relying on default of declaration\n            localVars.anchorPeriod = 0;\n            localVars.anchorPrice = Exp({mantissa : localVars.pendingAnchorMantissa});\n\n            // Verify movement is within max swing of pending anchor (currently: 10%)\n            (err, localVars.swing) = calculateSwing(localVars.anchorPrice, localVars.price);\n            if (err != Error.NO_ERROR) {\n                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CALCULATE_SWING, uint(err));\n            }\n\n            // Fail when swing \u003e maxSwing\n            if (greaterThanExp(localVars.swing, maxSwing)) {\n                return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_MAX_SWING_CHECK, localVars.swing.mantissa);\n            }\n        } else {\n            localVars.anchorPeriod = anchors[asset].period;\n            localVars.anchorPrice = Exp({mantissa : anchors[asset].priceMantissa});\n\n            if (localVars.anchorPeriod != 0) {\n                (err, localVars.priceCapped, localVars.price) = capToMax(localVars.anchorPrice, localVars.price);\n                if (err != Error.NO_ERROR) {\n                    return failOracleWithDetails(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_CAP_TO_MAX, uint(err));\n                }\n                if (localVars.priceCapped) {\n                    // save for use in log\n                    localVars.cappingAnchorPriceMantissa = localVars.anchorPrice.mantissa;\n                }\n            } else {\n                // Setting first price. Accept as is (already assigned above from requestedPriceMantissa) and use as anchor\n                localVars.anchorPrice = Exp({mantissa : requestedPriceMantissa});\n            }\n        }\n\n        // Fail if anchorPrice or price is zero.\n        // zero anchor represents an unexpected situation likely due to a problem in this contract\n        // zero price is more likely as the result of bad input from the caller of this function\n        if (isZeroExp(localVars.anchorPrice)) {\n            // If we get here price could also be zero, but it does not seem worthwhile to distinguish the 3rd case\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_NO_ANCHOR_PRICE_OR_INITIAL_PRICE_ZERO);\n        }\n\n        if (isZeroExp(localVars.price)) {\n            return failOracle(asset, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICE_ZERO_PRICE);\n        }\n\n        // BEGIN SIDE EFFECTS\n\n        // Set pendingAnchor = Nothing\n        // Pending anchor is only used once.\n        if (pendingAnchors[asset] != 0) {\n            pendingAnchors[asset] = 0;\n        }\n\n        // If currentPeriod \u003e anchorPeriod:\n        //  Set anchors[asset] = (currentPeriod, price)\n        //  The new anchor is if we\u0027re in a new period or we had a pending anchor, then we become the new anchor\n        if (localVars.currentPeriod \u003e localVars.anchorPeriod) {\n            anchors[asset] = Anchor({period : localVars.currentPeriod, priceMantissa : localVars.price.mantissa});\n        }\n\n        uint previousPrice = _assetPrices[asset].mantissa;\n\n        setPriceStorageInternal(asset, localVars.price.mantissa);\n\n        emit PricePosted(asset, previousPrice, requestedPriceMantissa, localVars.price.mantissa);\n\n        if (localVars.priceCapped) {\n            // We have set a capped price. Log it so we can detect the situation and investigate.\n            emit CappedPricePosted(asset, requestedPriceMantissa, localVars.cappingAnchorPriceMantissa, localVars.price.mantissa);\n        }\n\n        return uint(OracleError.NO_ERROR);\n    }\n\n    // As a function to allow harness overrides\n    function setPriceStorageInternal(address asset, uint256 priceMantissa) internal {\n        _assetPrices[asset] = Exp({mantissa: priceMantissa});\n    }\n\n    // abs(price - anchorPrice) / anchorPrice\n    function calculateSwing(Exp memory anchorPrice, Exp memory price) pure internal returns (Error, Exp memory) {\n        Exp memory numerator;\n        Error err;\n\n        if (greaterThanExp(anchorPrice, price)) {\n            (err, numerator) = subExp(anchorPrice, price);\n            // can\u0027t underflow\n            assert(err == Error.NO_ERROR);\n        } else {\n            (err, numerator) = subExp(price, anchorPrice);\n            // Given greaterThan check above, price \u003e= anchorPrice so can\u0027t underflow.\n            assert(err == Error.NO_ERROR);\n        }\n\n        return divExp(numerator, anchorPrice);\n    }\n\n    function capToMax(Exp memory anchorPrice, Exp memory price) view internal returns (Error, bool, Exp memory) {\n        Exp memory one = Exp({mantissa : mantissaOne});\n        Exp memory onePlusMaxSwing;\n        Exp memory oneMinusMaxSwing;\n        Exp memory max;\n        Exp memory min;\n        // re-used for intermediate errors\n        Error err;\n\n        (err, onePlusMaxSwing) = addExp(one, maxSwing);\n        if (err != Error.NO_ERROR) {\n            return (err, false, Exp({mantissa : 0}));\n        }\n\n        // max = anchorPrice * (1 + maxSwing)\n        (err, max) = mulExp(anchorPrice, onePlusMaxSwing);\n        if (err != Error.NO_ERROR) {\n            return (err, false, Exp({mantissa : 0}));\n        }\n\n        // If price \u003e anchorPrice * (1 + maxSwing)\n        // Set price = anchorPrice * (1 + maxSwing)\n        if (greaterThanExp(price, max)) {\n            return (Error.NO_ERROR, true, max);\n        }\n\n        (err, oneMinusMaxSwing) = subExp(one, maxSwing);\n        if (err != Error.NO_ERROR) {\n            return (err, false, Exp({mantissa : 0}));\n        }\n\n        // min = anchorPrice * (1 - maxSwing)\n        (err, min) = mulExp(anchorPrice, oneMinusMaxSwing);\n        // We can\u0027t overflow here or we would have already overflowed above when calculating `max`\n        assert(err == Error.NO_ERROR);\n\n        // If  price \u003c anchorPrice * (1 - maxSwing)\n        // Set price = anchorPrice * (1 - maxSwing)\n        if (lessThanExp(price, min)) {\n            return (Error.NO_ERROR, true, min);\n        }\n\n        return (Error.NO_ERROR, false, price);\n    }\n\n    /**\n     * @notice entry point for updating multiple prices\n     * @dev function to set prices for a variable number of assets.\n     * @param assets a list of up to assets for which to set a price. required: 0 \u003c assets.length == requestedPriceMantissas.length\n     * @param requestedPriceMantissas requested new prices for the assets, scaled by 10**18. required: 0 \u003c assets.length == requestedPriceMantissas.length\n     * @return uint values in same order as inputs. For each: 0=success, otherwise a failure (see enum OracleError for details)\n     */\n    function setPrices(address[] assets, uint[] requestedPriceMantissas) public returns (uint[] memory) {\n        uint numAssets = assets.length;\n        uint numPrices = requestedPriceMantissas.length;\n        uint[] memory result;\n\n        // Fail when msg.sender is not poster\n        if (msg.sender != poster) {\n            result = new uint[](1);\n            result[0] = failOracle(0, OracleError.UNAUTHORIZED, OracleFailureInfo.SET_PRICE_PERMISSION_CHECK);\n            return result;\n        }\n\n        if ((numAssets == 0) || (numPrices != numAssets)) {\n            result = new uint[](1);\n            result[0] = failOracle(0, OracleError.FAILED_TO_SET_PRICE, OracleFailureInfo.SET_PRICES_PARAM_VALIDATION);\n            return result;\n        }\n\n        result = new uint[](numAssets);\n\n        for (uint i = 0; i \u003c numAssets; i++) {\n            result[i] = setPriceInternal(assets[i], requestedPriceMantissas[i]);\n        }\n\n        return result;\n    }\n}\n"},"PriceOracleInterface.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract PriceOracleInterface {\n    /**\n     * @notice Gets the price of a given asset\n     * @dev fetches the price of a given asset\n     * @param asset Asset to get the price of\n     * @return the price scaled by 10**18, or zero if the price is not available\n     */\n    function assetPrices(address asset) public view returns (uint);\n}\n"},"PriceOracleProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./PriceOracleInterface.sol\";\n\n\ncontract PriceOracleProxy {\n    address public mostRecentCaller;\n    uint public mostRecentBlock;\n    PriceOracleInterface public realPriceOracle;\n\n    constructor(address realPriceOracle_) public {\n        realPriceOracle = PriceOracleInterface(realPriceOracle_);\n    }\n\n    /**\n     * @notice Gets the price of a given asset\n     * @dev fetches the price of a given asset\n     * @param asset Asset to get the price of\n     * @return the price scaled by 10**18, or zero if the price is not available\n     */\n    function assetPrices(address asset) public returns (uint) {\n        mostRecentCaller = tx.origin;\n        mostRecentBlock = block.number;\n\n        return realPriceOracle.assetPrices(asset);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.24;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"SafeToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ErrorReporter.sol\";\n\ncontract SafeToken is ErrorReporter {\n\n    /**\n     * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and\n     *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.\n     */\n    function checkTransferIn(address asset, address from, uint amount) internal view returns (Error) {\n        EIP20Interface token = EIP20Interface(asset);\n\n        if (token.allowance(from, address(this)) \u003c amount) {\n            return Error.TOKEN_INSUFFICIENT_ALLOWANCE;\n        }\n\n        if (token.balanceOf(from) \u003c amount) {\n            return Error.TOKEN_INSUFFICIENT_BALANCE;\n        }\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and returns an explanatory\n     *      error code rather than reverting.  If caller has not called `checkTransferIn`, this may revert due to\n     *      insufficient balance or insufficient allowance. If caller has called `checkTransferIn` prior to this call,\n     *      and it returned Error.NO_ERROR, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferIn(address asset, address from, uint amount) internal returns (Error) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\n\n        bool result;\n\n        token.transferFrom(from, address(this), amount);\n\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    result := not(0)          // set result to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    result := mload(0)        // Set `result = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        if (!result) {\n            return Error.TOKEN_TRANSFER_FAILED;\n        }\n\n        return Error.NO_ERROR;\n    }\n\n    /**\n     * @dev Checks balance of this contract in asset\n     */\n    function getCash(address asset) internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(asset);\n\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Checks balance of `from` in `asset`\n     */\n    function getBalanceOf(address asset, address from) internal view returns (uint) {\n        EIP20Interface token = EIP20Interface(asset);\n\n        return token.balanceOf(from);\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol\u0027s balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol\u0027s balance prior to this call, and verified\n     *      it is \u003e= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n    function doTransferOut(address asset, address to, uint amount) internal returns (Error) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\n\n        bool result;\n\n        token.transfer(to, amount);\n\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    result := not(0)          // set result to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    result := mload(0)        // Set `result = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n\n        if (!result) {\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n        }\n\n        return Error.NO_ERROR;\n    }\n\n    function doApprove(address asset, address to, uint amount) internal returns (Error) {\n        EIP20NonStandardInterface token = EIP20NonStandardInterface(asset);\n        bool result;\n        token.approve(to, amount);\n        assembly {\n            switch returndatasize()\n                case 0 {                      // This is a non-standard ERC-20\n                    result := not(0)          // set result to true\n                }\n                case 32 {                     // This is a complaint ERC-20\n                    returndatacopy(0, 0, 32)\n                    result := mload(0)        // Set `result = returndata` of external call\n                }\n                default {                     // This is an excessively non-compliant ERC-20, revert.\n                    revert(0, 0)\n                }\n        }\n        if (!result) {\n            return Error.TOKEN_TRANSFER_OUT_FAILED;\n        }\n        return Error.NO_ERROR;\n    }\n}\n"},"TestTokens.sol":{"content":"pragma solidity 0.4.24;\n\ncontract TestTokens {\n//Variables\nstring public name;\nstring public symbol; // Usually is 3 or 4 letters long\nuint8 public decimals; // maximum is 18 decimals\nuint256 public supply;\n\nmapping(address =\u003e uint) public balances;\nmapping(address =\u003e mapping(address =\u003e uint)) public allowed;\n//Events\nevent Transfer(address sender, address receiver, uint256 tokens);\nevent Approval(address sender, address delegate, uint256 tokens);\n//constructor\nconstructor (string memory _name, string memory _symbol, uint8 _decimals, uint256 _supply) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n    supply = _supply * 10**18;\n    balances[msg.sender] = _supply * 10**18;\n}\n//Functions\n//return the total number of tokens that you have\nfunction totalSupply() external view returns (uint256){\n    return supply;\n}\n\n//How many tokens does this person have\nfunction balanceOf(address tokenOwner) external view returns (uint){\n    return balances[tokenOwner];\n}\n\n//helps in transferring from your account to another person\nfunction transfer(address receiver, uint numTokens) external returns (bool){\n    require(msg.sender != receiver,\"Sender and receiver can\u0027t be the same\");\n    require(balances[msg.sender] \u003e= numTokens,\"Not enough balance\");\n    balances[msg.sender] -= numTokens;\n    balances[receiver] += numTokens;\n    emit Transfer(msg.sender,receiver,numTokens);\n    return true;\n}\n\n// Used to delegate authority to send tokens without my approval\nfunction approve(address delegate, uint numTokens) external returns (bool){\n    require(msg.sender != delegate,\"Sender and delegate can\u0027t be the same\");\n    allowed[msg.sender][delegate] = numTokens;\n    emit Approval(msg.sender,delegate,numTokens);\n    return true;\n}\n\n// How much has the owner delegated/approved to the delegate\nfunction allowance(address owner, address delegate) external view returns (uint){\n    return allowed[owner][delegate];\n}\n\n// Used by exchanges to send money from owner to buyer\nfunction transferFrom(address owner, address buyer, uint numTokens) external returns (bool){\n    require(owner != buyer,\"Owner and Buyer can\u0027t be the same\");\n    require(balances[owner] \u003e= numTokens,\"Not enough balance\");\n    require(allowed[owner][msg.sender] \u003e= numTokens,\"Not enough allowance\");\n    balances[owner] -= numTokens;\n    balances[buyer] += numTokens;\n    allowed[owner][msg.sender] -= numTokens;\n    emit Transfer(owner,buyer,numTokens);\n    return true;\n}\n\n// Should not be used in production\n// Only to allocate testnet tokens to user for testing purposes\nfunction allocateTo(address _owner, uint256 value) public {\n        balances[_owner] += value;\n        supply += value;\n        emit Transfer(address(this), _owner, value);\n    }\n}\n"}}